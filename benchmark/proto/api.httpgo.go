// Code generated by protoc-gen-httpgo. DO NOT EDIT.
// source: proto/api.proto

package proto

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	router "github.com/fasthttp/router"
	fasthttp "github.com/valyala/fasthttp"
	strconv "strconv"
)

type APIMeasureHTTPGoService interface {
	Measure(context.Context, *MeasureRequest) (*MeasureRequest, error)
}

func RegisterAPIMeasureHTTPGoServer(
	_ context.Context,
	r *router.Router,
	h APIMeasureHTTPGoService,
	middlewares []func(ctx context.Context, req any, handler func(ctx context.Context, req any) (resp any, err error)) (resp any, err error),
) error {
	var middleware = chainServerMiddlewaresApi(middlewares)

	r.POST("/v1/measure", func(fastctx *fasthttp.RequestCtx) {
		fastctx.Response.Header.SetContentType("application/json")
		input, err := buildApiAPIMeasureMeasureMeasureRequest(fastctx)
		if err != nil {
			fastctx.SetStatusCode(fasthttp.StatusBadRequest)
			respJson, _ := json.Marshal(struct{ Error string }{Error: err.Error()})
			_, _ = fastctx.Write(respJson)
			return
		}
		ctx := context.WithValue(fastctx, "request", fastctx)
		ctx = context.WithValue(ctx, "proto_service", "APIMeasure")
		ctx = context.WithValue(ctx, "proto_method", "Measure")
		handler := func(ctx context.Context, req any) (resp any, err error) {
			return h.Measure(ctx, input)
		}
		var resp any
		if middleware == nil {
			resp, _ = handler(ctx, input)
		} else {
			resp, _ = middleware(ctx, input, handler)
		}
		respJson, _ := json.Marshal(resp)
		_, _ = fastctx.Write(respJson)
	})

	return nil
}

func buildApiAPIMeasureMeasureMeasureRequest(ctx *fasthttp.RequestCtx) (arg *MeasureRequest, err error) {
	arg = &MeasureRequest{}
	var body = ctx.PostBody()
	if len(body) > 0 {
		if err = json.Unmarshal(body, arg); err != nil {
			return nil, err
		}
	}
	ctx.QueryArgs().VisitAll(func(keyB, valueB []byte) {
		var key = string(keyB)
		var value = string(valueB)
		switch key {
		case "BoolValue":
			switch value {
			case "true", "t", "1":
				arg.BoolValue = true
			case "false", "f", "0":
				arg.BoolValue = false
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "Int32Value":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			arg.Int32Value = int32(Int32Value)
		case "Sint32Value":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			arg.Sint32Value = int32(Sint32Value)
		case "Uint32Value":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			arg.Uint32Value = uint32(Uint32Value)
		case "Int64Value":
			arg.Int64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", err)
				return
			}
		case "Sint64Value":
			arg.Sint64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", err)
				return
			}
		case "Uint64Value":
			arg.Uint64Value, err = strconv.ParseUint(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", err)
				return
			}
		case "Sfixed32Value":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			arg.Sfixed32Value = int32(Sfixed32Value)
		case "Fixed32Value":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			arg.Fixed32Value = uint32(Fixed32Value)
		case "FloatValue":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			arg.FloatValue = float32(FloatValue)
		case "Sfixed64Value":
			arg.Sfixed64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", err)
				return
			}
		case "Fixed64Value":
			arg.Fixed64Value, err = strconv.ParseUint(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", err)
				return
			}
		case "DoubleValue":
			arg.DoubleValue, err = strconv.ParseFloat(value, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", err)
				return
			}
		case "StringValue":
			arg.StringValue = value
		case "BytesValue":
			arg.BytesValue = []byte(value)
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	})
	return arg, err
}

func chainServerMiddlewaresApi(
	middlewares []func(ctx context.Context, req any, handler func(ctx context.Context, req any) (resp any, err error)) (resp any, err error),
) func(ctx context.Context, req any, handler func(ctx context.Context, req any) (resp any, err error)) (resp any, err error) {
	switch len(middlewares) {
	case 0:
		return nil
	case 1:
		return middlewares[0]
	default:
		return func(ctx context.Context, req any, handler func(ctx context.Context, req any) (resp any, err error)) (resp any, err error) {
			return middlewares[0](ctx, req, getChainServerMiddlewareHandlerApi(middlewares, 0, handler))
		}
	}
}

func getChainServerMiddlewareHandlerApi(
	middlewares []func(ctx context.Context, req any, handler func(ctx context.Context, req any) (resp any, err error)) (resp any, err error),
	curr int,
	finalHandler func(ctx context.Context, req any) (resp any, err error),
) func(ctx context.Context, req any) (resp any, err error) {
	if curr == len(middlewares)-1 {
		return finalHandler
	}
	return func(ctx context.Context, req any) (resp any, err error) {
		return middlewares[curr+1](ctx, req, getChainServerMiddlewareHandlerApi(middlewares, curr+1, finalHandler))
	}
}

var _ APIMeasureHTTPGoService = &APIMeasureHTTPGoClient{}

type APIMeasureHTTPGoClient struct {
	cl          *fasthttp.Client
	host        string
	middlewares []func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error)
	middleware  func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error)
}

func GetAPIMeasureHTTPGoClient(
	_ context.Context,
	cl *fasthttp.Client,
	host string,
	middlewares []func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error),
) (*APIMeasureHTTPGoClient, error) {
	return &APIMeasureHTTPGoClient{
		cl:          cl,
		host:        host,
		middlewares: middlewares,
		middleware:  chainClientMiddlewaresApi(middlewares),
	}, nil
}

func (p *APIMeasureHTTPGoClient) Measure(ctx context.Context, request *MeasureRequest) (resp *MeasureRequest, err error) {
	req := fasthttp.AcquireRequest()
	defer fasthttp.ReleaseRequest(req)
	var queryArgs string
	var body []byte
	body, err = json.Marshal(request)
	if err != nil {
		return nil, err
	}
	req.SetBody(body)
	req.SetRequestURI(fmt.Sprintf("%s/v1/measure%s", p.host, queryArgs))
	req.Header.SetMethod("POST")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	var reqResp *fasthttp.Response
	ctx = context.WithValue(ctx, "proto_service", "APIMeasure")
	ctx = context.WithValue(ctx, "proto_method", "Measure")
	var handler = func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error) {
		resp = &fasthttp.Response{}
		err = p.cl.Do(req, resp)
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &MeasureRequest{}
	var respBody = reqResp.Body()
	err = json.Unmarshal(respBody, resp)
	return resp, err
}

func chainClientMiddlewaresApi(
	middlewares []func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error),
) func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error) {
	switch len(middlewares) {
	case 0:
		return nil
	case 1:
		return middlewares[0]
	default:
		return func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error) {
			return middlewares[0](ctx, req, getChainClientMiddlewareHandlerApi(middlewares, 0, handler))
		}
	}
}

func getChainClientMiddlewareHandlerApi(
	middlewares []func(ctx context.Context, req *fasthttp.Request, handler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error)) (resp *fasthttp.Response, err error),
	curr int,
	finalHandler func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error),
) func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error) {
	if curr == len(middlewares)-1 {
		return finalHandler
	}
	return func(ctx context.Context, req *fasthttp.Request) (resp *fasthttp.Response, err error) {
		return middlewares[curr+1](ctx, req, getChainClientMiddlewareHandlerApi(middlewares, curr+1, finalHandler))
	}
}
