// Code generated by protoc-gen-httpgo. DO NOT EDIT.
// source: proto/example.proto

package proto

import (
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	somepackage "github.com/MUlt1mate/protoc-gen-httpgo/example/proto/somepackage"
	router "github.com/fasthttp/router"
	easyjson "github.com/mailru/easyjson"
	fasthttp "github.com/valyala/fasthttp"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	log "log"
	strconv "strconv"
	strings "strings"
)

type ServiceNameHTTPGoService interface {
	RPCName(context.Context, *InputMsgName) (*OutputMsgName, error)
	AllTypesTest(context.Context, *AllTypesMsg) (*AllTypesMsg, error)
	CommonTypes(context.Context, *anypb.Any) (*emptypb.Empty, error)
	Imports(context.Context, *somepackage.SomeCustomMsg1) (*somepackage.SomeCustomMsg2, error)
	SameInputAndOutput(context.Context, *InputMsgName) (*OutputMsgName, error)
}

func RegisterServiceNameHTTPGoServer(
	ctx context.Context,
	r *router.Router,
	h ServiceNameHTTPGoService,
	middlewares []func(ctx *fasthttp.RequestCtx, handler func(ctx *fasthttp.RequestCtx)),
) error {
	var middleware = chainMiddlewaresExample(middlewares)
	r.POST("/v1/test/{stringArgument}/{int64Argument}", func(ctx *fasthttp.RequestCtx) {
		handler := func(ctx *fasthttp.RequestCtx) {
			input, err := buildExampleServiceNameRPCNameInputMsgName(ctx)
			if err != nil {
				responseHandlerExample(ctx, nil, err)
				return
			}
			response, err := h.RPCName(ctx, input)
			responseHandlerExample(ctx, response, err)
		}
		if middleware == nil {
			handler(ctx)
			return
		}
		middleware(ctx, handler)
	})

	r.POST("/v1/test/{BoolValue}/{EnumValue}/{Int32Value}/{Sint32Value}/{Uint32Value}/{Int64Value}/{Sint64Value}/{Uint64Value}/{Sfixed32Value}/{Fixed32Value}/{FloatValue}/{Sfixed64Value}/{Fixed64Value}/{DoubleValue}/{StringValue}/{BytesValue}", func(ctx *fasthttp.RequestCtx) {
		handler := func(ctx *fasthttp.RequestCtx) {
			input, err := buildExampleServiceNameAllTypesTestAllTypesMsg(ctx)
			if err != nil {
				responseHandlerExample(ctx, nil, err)
				return
			}
			response, err := h.AllTypesTest(ctx, input)
			responseHandlerExample(ctx, response, err)
		}
		if middleware == nil {
			handler(ctx)
			return
		}
		middleware(ctx, handler)
	})

	r.POST("/v1/test/commonTypes", func(ctx *fasthttp.RequestCtx) {
		handler := func(ctx *fasthttp.RequestCtx) {
			input, err := buildExampleServiceNameCommonTypesAny(ctx)
			if err != nil {
				responseHandlerExample(ctx, nil, err)
				return
			}
			response, err := h.CommonTypes(ctx, input)
			responseHandlerExample(ctx, response, err)
		}
		if middleware == nil {
			handler(ctx)
			return
		}
		middleware(ctx, handler)
	})

	r.POST("/v1/test/imports", func(ctx *fasthttp.RequestCtx) {
		handler := func(ctx *fasthttp.RequestCtx) {
			input, err := buildExampleServiceNameImportsSomeCustomMsg1(ctx)
			if err != nil {
				responseHandlerExample(ctx, nil, err)
				return
			}
			response, err := h.Imports(ctx, input)
			responseHandlerExample(ctx, response, err)
		}
		if middleware == nil {
			handler(ctx)
			return
		}
		middleware(ctx, handler)
	})

	r.POST("/v1/test/{stringArgument}", func(ctx *fasthttp.RequestCtx) {
		handler := func(ctx *fasthttp.RequestCtx) {
			input, err := buildExampleServiceNameSameInputAndOutputInputMsgName(ctx)
			if err != nil {
				responseHandlerExample(ctx, nil, err)
				return
			}
			response, err := h.SameInputAndOutput(ctx, input)
			responseHandlerExample(ctx, response, err)
		}
		if middleware == nil {
			handler(ctx)
			return
		}
		middleware(ctx, handler)
	})

	return nil
}

func buildExampleServiceNameRPCNameInputMsgName(ctx *fasthttp.RequestCtx) (arg *InputMsgName, err error) {
	arg = &InputMsgName{}
	if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(ctx.PostBody(), argEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(ctx.PostBody(), arg); err != nil {
			return nil, err
		}
	}
	StringArgumentStr, ok := ctx.UserValue("stringArgument").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter StringArgument")
	}
	arg.StringArgument = StringArgumentStr

	Int64ArgumentStr, ok := ctx.UserValue("int64Argument").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Int64Argument")
	}
	arg.Int64Argument, err = strconv.ParseInt(Int64ArgumentStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Int64Argument: %w", err)
	}

	return arg, err
}

func buildExampleServiceNameAllTypesTestAllTypesMsg(ctx *fasthttp.RequestCtx) (arg *AllTypesMsg, err error) {
	arg = &AllTypesMsg{}
	if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(ctx.PostBody(), argEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(ctx.PostBody(), arg); err != nil {
			return nil, err
		}
	}
	BoolValueStr, ok := ctx.UserValue("BoolValue").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter BoolValue")
	}
	switch BoolValueStr {
	case "true", "t", "1":
		arg.BoolValue = true
	case "false", "f", "0":
		arg.BoolValue = false
	default:
		return nil, fmt.Errorf("unknown bool string value %s", BoolValueStr)
	}

	EnumValueStr, ok := ctx.UserValue("EnumValue").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter EnumValue")
	}
	if OptionsValue, ok := Options_value[strings.ToUpper(EnumValueStr)]; ok {
		arg.EnumValue = Options(OptionsValue)
	} else {
		if intOptionValue, err := strconv.ParseInt(EnumValueStr, 10, 32); err == nil {
			if _, ok := Options_name[int32(intOptionValue)]; ok {
				arg.EnumValue = Options(intOptionValue)
			}
		}
	}

	Int32ValueStr, ok := ctx.UserValue("Int32Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Int32Value")
	}
	Int32Value, err := strconv.ParseInt(Int32ValueStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Int32Value: %w", err)
	}
	arg.Int32Value = int32(Int32Value)

	Sint32ValueStr, ok := ctx.UserValue("Sint32Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Sint32Value")
	}
	Sint32Value, err := strconv.ParseInt(Sint32ValueStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sint32Value: %w", err)
	}
	arg.Sint32Value = int32(Sint32Value)

	Uint32ValueStr, ok := ctx.UserValue("Uint32Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Uint32Value")
	}
	Uint32Value, err := strconv.ParseInt(Uint32ValueStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Uint32Value: %w", err)
	}
	arg.Uint32Value = uint32(Uint32Value)

	Int64ValueStr, ok := ctx.UserValue("Int64Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Int64Value")
	}
	arg.Int64Value, err = strconv.ParseInt(Int64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Int64Value: %w", err)
	}

	Sint64ValueStr, ok := ctx.UserValue("Sint64Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Sint64Value")
	}
	arg.Sint64Value, err = strconv.ParseInt(Sint64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sint64Value: %w", err)
	}

	Uint64ValueStr, ok := ctx.UserValue("Uint64Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Uint64Value")
	}
	Uint64Value, err := strconv.ParseInt(Uint64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Uint64Value: %w", err)
	}
	arg.Uint64Value = uint64(Uint64Value)

	Sfixed32ValueStr, ok := ctx.UserValue("Sfixed32Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Sfixed32Value")
	}
	Sfixed32Value, err := strconv.ParseInt(Sfixed32ValueStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", err)
	}
	arg.Sfixed32Value = int32(Sfixed32Value)

	Fixed32ValueStr, ok := ctx.UserValue("Fixed32Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Fixed32Value")
	}
	Fixed32Value, err := strconv.ParseInt(Fixed32ValueStr, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Fixed32Value: %w", err)
	}
	arg.Fixed32Value = uint32(Fixed32Value)

	FloatValueStr, ok := ctx.UserValue("FloatValue").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter FloatValue")
	}
	FloatValue, err := strconv.ParseFloat(FloatValueStr, 32)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter FloatValue: %w", err)
	}
	arg.FloatValue = float32(FloatValue)

	Sfixed64ValueStr, ok := ctx.UserValue("Sfixed64Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Sfixed64Value")
	}
	arg.Sfixed64Value, err = strconv.ParseInt(Sfixed64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", err)
	}

	Fixed64ValueStr, ok := ctx.UserValue("Fixed64Value").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter Fixed64Value")
	}
	Fixed64Value, err := strconv.ParseInt(Fixed64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Fixed64Value: %w", err)
	}
	arg.Fixed64Value = uint64(Fixed64Value)

	DoubleValueStr, ok := ctx.UserValue("DoubleValue").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter DoubleValue")
	}
	arg.DoubleValue, err = strconv.ParseFloat(DoubleValueStr, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter DoubleValue: %w", err)
	}

	StringValueStr, ok := ctx.UserValue("StringValue").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter StringValue")
	}
	arg.StringValue = StringValueStr

	BytesValueStr, ok := ctx.UserValue("BytesValue").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter BytesValue")
	}
	arg.BytesValue = []byte(BytesValueStr)

	return arg, err
}

func buildExampleServiceNameCommonTypesAny(ctx *fasthttp.RequestCtx) (arg *anypb.Any, err error) {
	arg = &anypb.Any{}
	if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(ctx.PostBody(), argEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(ctx.PostBody(), arg); err != nil {
			return nil, err
		}
	}
	return arg, err
}

func buildExampleServiceNameImportsSomeCustomMsg1(ctx *fasthttp.RequestCtx) (arg *somepackage.SomeCustomMsg1, err error) {
	arg = &somepackage.SomeCustomMsg1{}
	if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(ctx.PostBody(), argEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(ctx.PostBody(), arg); err != nil {
			return nil, err
		}
	}
	return arg, err
}

func buildExampleServiceNameSameInputAndOutputInputMsgName(ctx *fasthttp.RequestCtx) (arg *InputMsgName, err error) {
	arg = &InputMsgName{}
	if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(ctx.PostBody(), argEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(ctx.PostBody(), arg); err != nil {
			return nil, err
		}
	}
	StringArgumentStr, ok := ctx.UserValue("stringArgument").(string)
	if !ok {
		return nil, errors.New("incorrect type for parameter StringArgument")
	}
	arg.StringArgument = StringArgumentStr

	return arg, err
}

func responseHandlerExample(ctx *fasthttp.RequestCtx, resp interface{}, respErr error) {
	ctx.SetContentType("application/json")

	if respErr == nil {
		ctx.SetStatusCode(fasthttp.StatusOK)
	} else {
		log.Println(respErr)
		ctx.SetStatusCode(fasthttp.StatusInternalServerError)
	}

	var data []byte
	if _, ok := resp.(easyjson.Marshaler); ok {
		data, _ = easyjson.Marshal(resp.(easyjson.Marshaler))
	} else {
		data, _ = json.Marshal(resp)
	}
	_, _ = ctx.Write(data)
}

func chainMiddlewaresExample(
	middlewares []func(ctx *fasthttp.RequestCtx, handler func(ctx *fasthttp.RequestCtx)),
) func(ctx *fasthttp.RequestCtx, handler func(ctx *fasthttp.RequestCtx)) {
	switch len(middlewares) {
	case 0:
		return nil
	case 1:
		return middlewares[0]
	default:
		return func(ctx *fasthttp.RequestCtx, handler func(ctx *fasthttp.RequestCtx)) {
			middlewares[0](ctx, getChainMiddlewareHandlerExample(middlewares, 0, handler))
		}
	}
}

func getChainMiddlewareHandlerExample(
	middlewares []func(ctx *fasthttp.RequestCtx, handler func(ctx *fasthttp.RequestCtx)),
	curr int,
	finalHandler func(ctx *fasthttp.RequestCtx),
) func(ctx *fasthttp.RequestCtx) {
	if curr == len(middlewares)-1 {
		return finalHandler
	}
	return func(ctx *fasthttp.RequestCtx) {
		middlewares[curr+1](ctx, getChainMiddlewareHandlerExample(middlewares, curr+1, finalHandler))
	}
}
