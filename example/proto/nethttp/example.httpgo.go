// Code generated by protoc-gen-httpgo. DO NOT EDIT.
// source: example.proto

package proto

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	common "github.com/MUlt1mate/protoc-gen-httpgo/example/proto/common"
	easyjson "github.com/mailru/easyjson"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	multipart "mime/multipart"
	http "net/http"
	url "net/url"
	strconv "strconv"
	strings "strings"
)

type ServiceNameHTTPGoService interface {
	RPCName(context.Context, *common.InputMsgName) (*common.OutputMsgName, error)
	AllTypesTest(context.Context, *common.AllTypesMsg) (*common.AllTypesMsg, error)
	AllTextTypesPost(context.Context, *common.AllTextTypesMsg) (*common.AllTextTypesMsg, error)
	AllTextTypesGet(context.Context, *common.AllTextTypesMsg) (*common.AllTextTypesMsg, error)
	CommonTypes(context.Context, *anypb.Any) (*emptypb.Empty, error)
	SameInputAndOutput(context.Context, *common.InputMsgName) (*common.OutputMsgName, error)
	Optional(context.Context, *common.OptionalField) (*common.OptionalField, error)
	GetMethod(context.Context, *common.InputMsgName) (*common.OutputMsgName, error)
	CheckRepeatedPath(context.Context, *common.RepeatedCheck) (*common.RepeatedCheck, error)
	CheckRepeatedQuery(context.Context, *common.RepeatedCheck) (*common.RepeatedCheck, error)
	CheckRepeatedPost(context.Context, *common.RepeatedCheck) (*common.RepeatedCheck, error)
	EmptyGet(context.Context, *common.Empty) (*common.Empty, error)
	EmptyPost(context.Context, *common.Empty) (*common.Empty, error)
	TopLevelArray(context.Context, *common.Empty) (*common.Array, error)
	OnlyStructInGet(context.Context, *common.OnlyStruct) (*common.Empty, error)
	MultipartForm(context.Context, *common.MultipartFormRequest) (*common.Empty, error)
	MultipartFormAllTypes(context.Context, *common.MultipartFormAllTypes) (*common.Empty, error)
}

func RegisterServiceNameHTTPGoServer(
	_ context.Context,
	r *http.ServeMux,
	h ServiceNameHTTPGoService,
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error),
) error {
	var middleware = chainServerMiddlewaresExample(middlewares)

	r.HandleFunc("POST /v1/test/{stringArgument}/{int64Argument}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameRPCNameInputMsgName(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "RPCName")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.RPCName(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/test/{BoolValue}/{EnumValue}/{Int32Value}/{Sint32Value}/{Uint32Value}/{Int64Value}/{Sint64Value}/{Uint64Value}/{Sfixed32Value}/{Fixed32Value}/{FloatValue}/{Sfixed64Value}/{Fixed64Value}/{DoubleValue}/{StringValue}/{BytesValue}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameAllTypesTestAllTypesMsg(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "AllTypesTest")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.AllTypesTest(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/text/{String}/{RepeatedString}/{Bytes}/{RepeatedBytes}/{Enum}/{RepeatedEnum}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameAllTextTypesPostAllTextTypesMsg(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "AllTextTypesPost")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.AllTextTypesPost(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("GET /v2/text/{String}/{RepeatedString}/{Bytes}/{RepeatedBytes}/{Enum}/{RepeatedEnum}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameAllTextTypesGetAllTextTypesMsg(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "AllTextTypesGet")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.AllTextTypesGet(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/test/commonTypes", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameCommonTypesAny(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "CommonTypes")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.CommonTypes(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	// same types but different query, we need different query builder function
	r.HandleFunc("POST /v1/test/{stringArgument}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameSameInputAndOutputInputMsgName(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "SameInputAndOutput")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.SameInputAndOutput(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/test/optional", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameOptionalOptionalField(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "Optional")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.Optional(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("GET /v1/test/get", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameGetMethodInputMsgName(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "GetMethod")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.GetMethod(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("GET /v1/repeated/{BoolValue}/{EnumValue}/{Int32Value}/{Sint32Value}/{Uint32Value}/{Int64Value}/{Sint64Value}/{Uint64Value}/{Sfixed32Value}/{Fixed32Value}/{FloatValue}/{Sfixed64Value}/{Fixed64Value}/{DoubleValue}/{StringValue}/{BytesValue}/{StringValueQuery}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameCheckRepeatedPathRepeatedCheck(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "CheckRepeatedPath")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.CheckRepeatedPath(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("GET /v1/repeated/{StringValue}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameCheckRepeatedQueryRepeatedCheck(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "CheckRepeatedQuery")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.CheckRepeatedQuery(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/repeated/{StringValue}", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameCheckRepeatedPostRepeatedCheck(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "CheckRepeatedPost")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.CheckRepeatedPost(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("GET /v1/emptyGet", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameEmptyGetEmpty(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "EmptyGet")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.EmptyGet(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/emptyPost", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameEmptyPostEmpty(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "EmptyPost")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.EmptyPost(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/array", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameTopLevelArrayEmpty(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "TopLevelArray")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.TopLevelArray(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/onlyStruct", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameOnlyStructInGetOnlyStruct(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "OnlyStructInGet")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.OnlyStructInGet(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/multipart", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameMultipartFormMultipartFormRequest(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "MultipartForm")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.MultipartForm(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	r.HandleFunc("POST /v1/multipartall", func(w http.ResponseWriter, r *http.Request) {
		input, err := buildExampleServiceNameMultipartFormAllTypesMultipartFormAllTypes(r)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(err.Error()))
			return
		}
		ctx := r.Context()
		ctx = context.WithValue(ctx, "proto_service", "ServiceName")
		ctx = context.WithValue(ctx, "proto_method", "MultipartFormAllTypes")
		ctx = context.WithValue(ctx, "writer", w)
		ctx = context.WithValue(ctx, "request", r)
		handler := func(ctx context.Context, req interface{}) (resp interface{}, err error) {
			return h.MultipartFormAllTypes(ctx, input)
		}
		if middleware == nil {
			_, _ = handler(ctx, input)
			return
		}
		_, _ = middleware(ctx, input, handler)
	})

	return nil
}

func buildExampleServiceNameRPCNameInputMsgName(r *http.Request) (arg *common.InputMsgName, err error) {
	arg = &common.InputMsgName{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "int64Argument":
			arg.Int64Argument, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter int64Argument: %w", err)
				return
			}
		case "stringArgument":
			arg.StringArgument = value
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	StringArgumentStr := r.PathValue("stringArgument")
	if len(StringArgumentStr) == 0 {
		return nil, errors.New("empty value for parameter stringArgument")
	}
	arg.StringArgument = StringArgumentStr

	Int64ArgumentStr := r.PathValue("int64Argument")
	if len(Int64ArgumentStr) == 0 {
		return nil, errors.New("empty value for parameter int64Argument")
	}
	arg.Int64Argument, err = strconv.ParseInt(Int64ArgumentStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter int64Argument: %w", err)
	}

	return arg, err
}

func buildExampleServiceNameAllTypesTestAllTypesMsg(r *http.Request) (arg *common.AllTypesMsg, err error) {
	arg = &common.AllTypesMsg{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "BoolValue":
			switch value {
			case "true", "t", "1":
				arg.BoolValue = true
			case "false", "f", "0":
				arg.BoolValue = false
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "EnumValue":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.EnumValue = common.Options(OptionsValue)
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.EnumValue = common.Options(intOptionValue)
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
					return
				}
			}
		case "Int32Value":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			arg.Int32Value = int32(Int32Value)
		case "Sint32Value":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			arg.Sint32Value = int32(Sint32Value)
		case "Uint32Value":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			arg.Uint32Value = uint32(Uint32Value)
		case "Int64Value":
			arg.Int64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", err)
				return
			}
		case "Sint64Value":
			arg.Sint64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", err)
				return
			}
		case "Uint64Value":
			arg.Uint64Value, err = strconv.ParseUint(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", err)
				return
			}
		case "Sfixed32Value":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			arg.Sfixed32Value = int32(Sfixed32Value)
		case "Fixed32Value":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			arg.Fixed32Value = uint32(Fixed32Value)
		case "FloatValue":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			arg.FloatValue = float32(FloatValue)
		case "Sfixed64Value":
			arg.Sfixed64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", err)
				return
			}
		case "Fixed64Value":
			arg.Fixed64Value, err = strconv.ParseUint(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", err)
				return
			}
		case "DoubleValue":
			arg.DoubleValue, err = strconv.ParseFloat(value, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", err)
				return
			}
		case "StringValue":
			arg.StringValue = value
		case "BytesValue":
			arg.BytesValue = []byte(value)
		case "MessageValue":
			err = fmt.Errorf("unsupported type message for query argument MessageValue")
			return
		case "SliceStringValue[]":
			arg.SliceStringValue = append(arg.SliceStringValue, value)
		case "SliceInt32Value[]":
			SliceInt32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter SliceInt32Value: %w", convErr)
				return
			}
			arg.SliceInt32Value = append(arg.SliceInt32Value, int32(SliceInt32Value))
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	BoolValueStr := r.PathValue("BoolValue")
	if len(BoolValueStr) == 0 {
		return nil, errors.New("empty value for parameter BoolValue")
	}
	switch BoolValueStr {
	case "true", "t", "1":
		arg.BoolValue = true
	case "false", "f", "0":
		arg.BoolValue = false
	default:
		return nil, fmt.Errorf("unknown bool string value %s", BoolValueStr)
	}

	EnumValueStr := r.PathValue("EnumValue")
	if len(EnumValueStr) == 0 {
		return nil, errors.New("empty value for parameter EnumValue")
	}
	if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(EnumValueStr)]; optValueOk {
		arg.EnumValue = common.Options(OptionsValue)
	} else {
		if intOptionValue, convErr := strconv.ParseInt(EnumValueStr, 10, 32); convErr == nil {
			if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
				arg.EnumValue = common.Options(intOptionValue)
			}
		} else {
			return nil, fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
		}
	}

	Int32ValueStr := r.PathValue("Int32Value")
	if len(Int32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Int32Value")
	}
	Int32Value, convErr := strconv.ParseInt(Int32ValueStr, 10, 32)
	if convErr != nil {
		return nil, fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
	}
	arg.Int32Value = int32(Int32Value)

	Sint32ValueStr := r.PathValue("Sint32Value")
	if len(Sint32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sint32Value")
	}
	Sint32Value, convErr := strconv.ParseInt(Sint32ValueStr, 10, 32)
	if convErr != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
	}
	arg.Sint32Value = int32(Sint32Value)

	Uint32ValueStr := r.PathValue("Uint32Value")
	if len(Uint32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Uint32Value")
	}
	Uint32Value, convErr := strconv.ParseUint(Uint32ValueStr, 10, 32)
	if convErr != nil {
		return nil, fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
	}
	arg.Uint32Value = uint32(Uint32Value)

	Int64ValueStr := r.PathValue("Int64Value")
	if len(Int64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Int64Value")
	}
	arg.Int64Value, err = strconv.ParseInt(Int64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Int64Value: %w", err)
	}

	Sint64ValueStr := r.PathValue("Sint64Value")
	if len(Sint64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sint64Value")
	}
	arg.Sint64Value, err = strconv.ParseInt(Sint64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sint64Value: %w", err)
	}

	Uint64ValueStr := r.PathValue("Uint64Value")
	if len(Uint64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Uint64Value")
	}
	arg.Uint64Value, err = strconv.ParseUint(Uint64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Uint64Value: %w", err)
	}

	Sfixed32ValueStr := r.PathValue("Sfixed32Value")
	if len(Sfixed32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sfixed32Value")
	}
	Sfixed32Value, convErr := strconv.ParseInt(Sfixed32ValueStr, 10, 32)
	if convErr != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
	}
	arg.Sfixed32Value = int32(Sfixed32Value)

	Fixed32ValueStr := r.PathValue("Fixed32Value")
	if len(Fixed32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Fixed32Value")
	}
	Fixed32Value, convErr := strconv.ParseUint(Fixed32ValueStr, 10, 32)
	if convErr != nil {
		return nil, fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
	}
	arg.Fixed32Value = uint32(Fixed32Value)

	FloatValueStr := r.PathValue("FloatValue")
	if len(FloatValueStr) == 0 {
		return nil, errors.New("empty value for parameter FloatValue")
	}
	FloatValue, convErr := strconv.ParseFloat(FloatValueStr, 32)
	if convErr != nil {
		return nil, fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
	}
	arg.FloatValue = float32(FloatValue)

	Sfixed64ValueStr := r.PathValue("Sfixed64Value")
	if len(Sfixed64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sfixed64Value")
	}
	arg.Sfixed64Value, err = strconv.ParseInt(Sfixed64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", err)
	}

	Fixed64ValueStr := r.PathValue("Fixed64Value")
	if len(Fixed64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Fixed64Value")
	}
	arg.Fixed64Value, err = strconv.ParseUint(Fixed64ValueStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter Fixed64Value: %w", err)
	}

	DoubleValueStr := r.PathValue("DoubleValue")
	if len(DoubleValueStr) == 0 {
		return nil, errors.New("empty value for parameter DoubleValue")
	}
	arg.DoubleValue, err = strconv.ParseFloat(DoubleValueStr, 64)
	if err != nil {
		return nil, fmt.Errorf("conversion failed for parameter DoubleValue: %w", err)
	}

	StringValueStr := r.PathValue("StringValue")
	if len(StringValueStr) == 0 {
		return nil, errors.New("empty value for parameter StringValue")
	}
	arg.StringValue = StringValueStr

	BytesValueStr := r.PathValue("BytesValue")
	if len(BytesValueStr) == 0 {
		return nil, errors.New("empty value for parameter BytesValue")
	}
	arg.BytesValue = []byte(BytesValueStr)

	return arg, err
}

func buildExampleServiceNameAllTextTypesPostAllTextTypesMsg(r *http.Request) (arg *common.AllTextTypesMsg, err error) {
	arg = &common.AllTextTypesMsg{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "String":
			arg.String_ = value
		case "RepeatedString[]":
			arg.RepeatedString = append(arg.RepeatedString, value)
		case "OptionalString":
			arg.OptionalString = &value
		case "Bytes":
			arg.Bytes = []byte(value)
		case "RepeatedBytes[]":
			arg.RepeatedBytes = append(arg.RepeatedBytes, []byte(value))
		case "OptionalBytes":
			arg.OptionalBytes = []byte(value)
		case "Enum":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.Enum = common.Options(OptionsValue)
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.Enum = common.Options(intOptionValue)
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter Enum: %w", convErr)
					return
				}
			}
		case "RepeatedEnum[]":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(OptionsValue))
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(intOptionValue))
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter RepeatedEnum: %w", convErr)
					return
				}
			}
		case "OptionalEnum":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				OptionalEnum := common.Options(OptionsValue)
				arg.OptionalEnum = &OptionalEnum
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						OptionalEnum := common.Options(intOptionValue)
						arg.OptionalEnum = &OptionalEnum
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter OptionalEnum: %w", convErr)
					return
				}
			}
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	String_Str := r.PathValue("String")
	if len(String_Str) == 0 {
		return nil, errors.New("empty value for parameter String")
	}
	arg.String_ = String_Str

	RepeatedStringStr := r.PathValue("RepeatedString")
	if len(RepeatedStringStr) == 0 {
		return nil, errors.New("empty value for parameter RepeatedString")
	}
	arg.RepeatedString = strings.Split(RepeatedStringStr, ",")
	BytesStr := r.PathValue("Bytes")
	if len(BytesStr) == 0 {
		return nil, errors.New("empty value for parameter Bytes")
	}
	arg.Bytes = []byte(BytesStr)

	RepeatedBytesStr := r.PathValue("RepeatedBytes")
	if len(RepeatedBytesStr) == 0 {
		return nil, errors.New("empty value for parameter RepeatedBytes")
	}
	arg.RepeatedBytes = append(arg.RepeatedBytes, []byte(RepeatedBytesStr))
	EnumStr := r.PathValue("Enum")
	if len(EnumStr) == 0 {
		return nil, errors.New("empty value for parameter Enum")
	}
	if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(EnumStr)]; optValueOk {
		arg.Enum = common.Options(OptionsValue)
	} else {
		if intOptionValue, convErr := strconv.ParseInt(EnumStr, 10, 32); convErr == nil {
			if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
				arg.Enum = common.Options(intOptionValue)
			}
		} else {
			return nil, fmt.Errorf("conversion failed for parameter Enum: %w", convErr)
		}
	}

	RepeatedEnumStr := r.PathValue("RepeatedEnum")
	if len(RepeatedEnumStr) == 0 {
		return nil, errors.New("empty value for parameter RepeatedEnum")
	}
	RepeatedEnumStrs := strings.Split(RepeatedEnumStr, ",")
	for _, str := range RepeatedEnumStrs {
		if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(str)]; optValueOk {
			arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(OptionsValue))
		} else {
			if intOptionValue, convErr := strconv.ParseInt(str, 10, 32); convErr == nil {
				if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
					arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(intOptionValue))
				}
			} else {
				return nil, fmt.Errorf("conversion failed for parameter RepeatedEnum: %w", convErr)
			}
		}
	}
	return arg, err
}

func buildExampleServiceNameAllTextTypesGetAllTextTypesMsg(r *http.Request) (arg *common.AllTextTypesMsg, err error) {
	arg = &common.AllTextTypesMsg{}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "String":
			arg.String_ = value
		case "RepeatedString[]":
			arg.RepeatedString = append(arg.RepeatedString, value)
		case "OptionalString":
			arg.OptionalString = &value
		case "Bytes":
			arg.Bytes = []byte(value)
		case "RepeatedBytes[]":
			arg.RepeatedBytes = append(arg.RepeatedBytes, []byte(value))
		case "OptionalBytes":
			arg.OptionalBytes = []byte(value)
		case "Enum":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.Enum = common.Options(OptionsValue)
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.Enum = common.Options(intOptionValue)
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter Enum: %w", convErr)
					return
				}
			}
		case "RepeatedEnum[]":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(OptionsValue))
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(intOptionValue))
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter RepeatedEnum: %w", convErr)
					return
				}
			}
		case "OptionalEnum":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				OptionalEnum := common.Options(OptionsValue)
				arg.OptionalEnum = &OptionalEnum
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						OptionalEnum := common.Options(intOptionValue)
						arg.OptionalEnum = &OptionalEnum
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter OptionalEnum: %w", convErr)
					return
				}
			}
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	String_Str := r.PathValue("String")
	if len(String_Str) == 0 {
		return nil, errors.New("empty value for parameter String")
	}
	arg.String_ = String_Str

	RepeatedStringStr := r.PathValue("RepeatedString")
	if len(RepeatedStringStr) == 0 {
		return nil, errors.New("empty value for parameter RepeatedString")
	}
	arg.RepeatedString = strings.Split(RepeatedStringStr, ",")
	BytesStr := r.PathValue("Bytes")
	if len(BytesStr) == 0 {
		return nil, errors.New("empty value for parameter Bytes")
	}
	arg.Bytes = []byte(BytesStr)

	RepeatedBytesStr := r.PathValue("RepeatedBytes")
	if len(RepeatedBytesStr) == 0 {
		return nil, errors.New("empty value for parameter RepeatedBytes")
	}
	arg.RepeatedBytes = append(arg.RepeatedBytes, []byte(RepeatedBytesStr))
	EnumStr := r.PathValue("Enum")
	if len(EnumStr) == 0 {
		return nil, errors.New("empty value for parameter Enum")
	}
	if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(EnumStr)]; optValueOk {
		arg.Enum = common.Options(OptionsValue)
	} else {
		if intOptionValue, convErr := strconv.ParseInt(EnumStr, 10, 32); convErr == nil {
			if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
				arg.Enum = common.Options(intOptionValue)
			}
		} else {
			return nil, fmt.Errorf("conversion failed for parameter Enum: %w", convErr)
		}
	}

	RepeatedEnumStr := r.PathValue("RepeatedEnum")
	if len(RepeatedEnumStr) == 0 {
		return nil, errors.New("empty value for parameter RepeatedEnum")
	}
	RepeatedEnumStrs := strings.Split(RepeatedEnumStr, ",")
	for _, str := range RepeatedEnumStrs {
		if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(str)]; optValueOk {
			arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(OptionsValue))
		} else {
			if intOptionValue, convErr := strconv.ParseInt(str, 10, 32); convErr == nil {
				if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
					arg.RepeatedEnum = append(arg.RepeatedEnum, common.Options(intOptionValue))
				}
			} else {
				return nil, fmt.Errorf("conversion failed for parameter RepeatedEnum: %w", convErr)
			}
		}
	}
	return arg, err
}

func buildExampleServiceNameCommonTypesAny(r *http.Request) (arg *anypb.Any, err error) {
	arg = &anypb.Any{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "typeUrl":
			arg.TypeUrl = value
		case "value":
			arg.Value = []byte(value)
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	return arg, err
}

func buildExampleServiceNameSameInputAndOutputInputMsgName(r *http.Request) (arg *common.InputMsgName, err error) {
	arg = &common.InputMsgName{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "int64Argument":
			arg.Int64Argument, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter int64Argument: %w", err)
				return
			}
		case "stringArgument":
			arg.StringArgument = value
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	StringArgumentStr := r.PathValue("stringArgument")
	if len(StringArgumentStr) == 0 {
		return nil, errors.New("empty value for parameter stringArgument")
	}
	arg.StringArgument = StringArgumentStr

	return arg, err
}

func buildExampleServiceNameOptionalOptionalField(r *http.Request) (arg *common.OptionalField, err error) {
	arg = &common.OptionalField{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "BoolValue":
			switch value {
			case "true", "t", "1":
				BoolValue := true
				arg.BoolValue = &BoolValue
			case "false", "f", "0":
				BoolValue := false
				arg.BoolValue = &BoolValue
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "EnumValue":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				EnumValue := common.Options(OptionsValue)
				arg.EnumValue = &EnumValue
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						EnumValue := common.Options(intOptionValue)
						arg.EnumValue = &EnumValue
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
					return
				}
			}
		case "Int32Value":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			Int32ValueValue := int32(Int32Value)
			arg.Int32Value = &Int32ValueValue
		case "Sint32Value":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			Sint32ValueValue := int32(Sint32Value)
			arg.Sint32Value = &Sint32ValueValue
		case "Uint32Value":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			Uint32ValueValue := uint32(Uint32Value)
			arg.Uint32Value = &Uint32ValueValue
		case "Int64Value":
			Int64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", convErr)
				return
			}
			arg.Int64Value = &Int64Value
		case "Sint64Value":
			Sint64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
				return
			}
			arg.Sint64Value = &Sint64Value
		case "Uint64Value":
			Uint64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", convErr)
				return
			}
			arg.Uint64Value = &Uint64Value
		case "Sfixed32Value":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			Sfixed32ValueValue := int32(Sfixed32Value)
			arg.Sfixed32Value = &Sfixed32ValueValue
		case "Fixed32Value":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			Fixed32ValueValue := uint32(Fixed32Value)
			arg.Fixed32Value = &Fixed32ValueValue
		case "FloatValue":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			FloatValueValue := float32(FloatValue)
			arg.FloatValue = &FloatValueValue
		case "Sfixed64Value":
			Sfixed64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", convErr)
				return
			}
			arg.Sfixed64Value = &Sfixed64Value
		case "Fixed64Value":
			Fixed64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
				return
			}
			arg.Fixed64Value = &Fixed64Value
		case "DoubleValue":
			DoubleValue, convErr := strconv.ParseFloat(value, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", convErr)
				return
			}
			arg.DoubleValue = &DoubleValue
		case "StringValue":
			arg.StringValue = &value
		case "BytesValue":
			arg.BytesValue = []byte(value)
		case "MessageValue":
			err = fmt.Errorf("unsupported type message for query argument MessageValue")
			return
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	return arg, err
}

func buildExampleServiceNameGetMethodInputMsgName(r *http.Request) (arg *common.InputMsgName, err error) {
	arg = &common.InputMsgName{}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "int64Argument":
			arg.Int64Argument, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter int64Argument: %w", err)
				return
			}
		case "stringArgument":
			arg.StringArgument = value
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	return arg, err
}

func buildExampleServiceNameCheckRepeatedPathRepeatedCheck(r *http.Request) (arg *common.RepeatedCheck, err error) {
	arg = &common.RepeatedCheck{}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "BoolValue[]":
			switch value {
			case "true", "t", "1":
				arg.BoolValue = append(arg.BoolValue, true)
			case "false", "f", "0":
				arg.BoolValue = append(arg.BoolValue, false)
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "EnumValue[]":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.EnumValue = append(arg.EnumValue, common.Options(OptionsValue))
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.EnumValue = append(arg.EnumValue, common.Options(intOptionValue))
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
					return
				}
			}
		case "Int32Value[]":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			arg.Int32Value = append(arg.Int32Value, int32(Int32Value))
		case "Sint32Value[]":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			arg.Sint32Value = append(arg.Sint32Value, int32(Sint32Value))
		case "Uint32Value[]":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			arg.Uint32Value = append(arg.Uint32Value, uint32(Uint32Value))
		case "Int64Value[]":
			Int64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", convErr)
				return
			}
			arg.Int64Value = append(arg.Int64Value, Int64Value)
		case "Sint64Value[]":
			Sint64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
				return
			}
			arg.Sint64Value = append(arg.Sint64Value, Sint64Value)
		case "Uint64Value[]":
			Uint64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", convErr)
				return
			}
			arg.Uint64Value = append(arg.Uint64Value, Uint64Value)
		case "Sfixed32Value[]":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			arg.Sfixed32Value = append(arg.Sfixed32Value, int32(Sfixed32Value))
		case "Fixed32Value[]":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			arg.Fixed32Value = append(arg.Fixed32Value, uint32(Fixed32Value))
		case "FloatValue[]":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			arg.FloatValue = append(arg.FloatValue, float32(FloatValue))
		case "Sfixed64Value[]":
			Sfixed64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", convErr)
				return
			}
			arg.Sfixed64Value = append(arg.Sfixed64Value, Sfixed64Value)
		case "Fixed64Value[]":
			Fixed64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
				return
			}
			arg.Fixed64Value = append(arg.Fixed64Value, Fixed64Value)
		case "DoubleValue[]":
			DoubleValue, convErr := strconv.ParseFloat(value, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", convErr)
				return
			}
			arg.DoubleValue = append(arg.DoubleValue, DoubleValue)
		case "StringValue[]":
			arg.StringValue = append(arg.StringValue, value)
		case "BytesValue[]":
			arg.BytesValue = append(arg.BytesValue, []byte(value))
		case "StringValueQuery[]":
			arg.StringValueQuery = append(arg.StringValueQuery, value)
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	BoolValueStr := r.PathValue("BoolValue")
	if len(BoolValueStr) == 0 {
		return nil, errors.New("empty value for parameter BoolValue")
	}
	BoolValueStrs := strings.Split(BoolValueStr, ",")
	for _, str := range BoolValueStrs {
		switch str {
		case "true", "t", "1":
			arg.BoolValue = append(arg.BoolValue, true)
		case "false", "f", "0":
			arg.BoolValue = append(arg.BoolValue, false)
		default:
			return nil, fmt.Errorf("unknown bool string value %s", str)
		}
	}
	EnumValueStr := r.PathValue("EnumValue")
	if len(EnumValueStr) == 0 {
		return nil, errors.New("empty value for parameter EnumValue")
	}
	EnumValueStrs := strings.Split(EnumValueStr, ",")
	for _, str := range EnumValueStrs {
		if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(str)]; optValueOk {
			arg.EnumValue = append(arg.EnumValue, common.Options(OptionsValue))
		} else {
			if intOptionValue, convErr := strconv.ParseInt(str, 10, 32); convErr == nil {
				if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
					arg.EnumValue = append(arg.EnumValue, common.Options(intOptionValue))
				}
			} else {
				return nil, fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
			}
		}
	}
	Int32ValueStr := r.PathValue("Int32Value")
	if len(Int32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Int32Value")
	}
	Int32ValueStrs := strings.Split(Int32ValueStr, ",")
	for _, str := range Int32ValueStrs {
		Int32Value, convErr := strconv.ParseInt(str, 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
		}
		arg.Int32Value = append(arg.Int32Value, int32(Int32Value))
	}
	Sint32ValueStr := r.PathValue("Sint32Value")
	if len(Sint32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sint32Value")
	}
	Sint32ValueStrs := strings.Split(Sint32ValueStr, ",")
	for _, str := range Sint32ValueStrs {
		Sint32Value, convErr := strconv.ParseInt(str, 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
		}
		arg.Sint32Value = append(arg.Sint32Value, int32(Sint32Value))
	}
	Uint32ValueStr := r.PathValue("Uint32Value")
	if len(Uint32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Uint32Value")
	}
	Uint32ValueStrs := strings.Split(Uint32ValueStr, ",")
	for _, str := range Uint32ValueStrs {
		Uint32Value, convErr := strconv.ParseUint(str, 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
		}
		arg.Uint32Value = append(arg.Uint32Value, uint32(Uint32Value))
	}
	Int64ValueStr := r.PathValue("Int64Value")
	if len(Int64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Int64Value")
	}
	Int64ValueStrs := strings.Split(Int64ValueStr, ",")
	for _, str := range Int64ValueStrs {
		Int64Value, convErr := strconv.ParseInt(str, 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Int64Value: %w", convErr)
		}
		arg.Int64Value = append(arg.Int64Value, Int64Value)
	}
	Sint64ValueStr := r.PathValue("Sint64Value")
	if len(Sint64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sint64Value")
	}
	Sint64ValueStrs := strings.Split(Sint64ValueStr, ",")
	for _, str := range Sint64ValueStrs {
		Sint64Value, convErr := strconv.ParseInt(str, 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
		}
		arg.Sint64Value = append(arg.Sint64Value, Sint64Value)
	}
	Uint64ValueStr := r.PathValue("Uint64Value")
	if len(Uint64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Uint64Value")
	}
	Uint64ValueStrs := strings.Split(Uint64ValueStr, ",")
	for _, str := range Uint64ValueStrs {
		Uint64Value, convErr := strconv.ParseUint(str, 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Uint64Value: %w", convErr)
		}
		arg.Uint64Value = append(arg.Uint64Value, Uint64Value)
	}
	Sfixed32ValueStr := r.PathValue("Sfixed32Value")
	if len(Sfixed32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sfixed32Value")
	}
	Sfixed32ValueStrs := strings.Split(Sfixed32ValueStr, ",")
	for _, str := range Sfixed32ValueStrs {
		Sfixed32Value, convErr := strconv.ParseInt(str, 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
		}
		arg.Sfixed32Value = append(arg.Sfixed32Value, int32(Sfixed32Value))
	}
	Fixed32ValueStr := r.PathValue("Fixed32Value")
	if len(Fixed32ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Fixed32Value")
	}
	Fixed32ValueStrs := strings.Split(Fixed32ValueStr, ",")
	for _, str := range Fixed32ValueStrs {
		Fixed32Value, convErr := strconv.ParseUint(str, 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
		}
		arg.Fixed32Value = append(arg.Fixed32Value, uint32(Fixed32Value))
	}
	FloatValueStr := r.PathValue("FloatValue")
	if len(FloatValueStr) == 0 {
		return nil, errors.New("empty value for parameter FloatValue")
	}
	FloatValueStrs := strings.Split(FloatValueStr, ",")
	for _, str := range FloatValueStrs {
		FloatValue, convErr := strconv.ParseFloat(str, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
		}
		arg.FloatValue = append(arg.FloatValue, float32(FloatValue))
	}
	Sfixed64ValueStr := r.PathValue("Sfixed64Value")
	if len(Sfixed64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Sfixed64Value")
	}
	Sfixed64ValueStrs := strings.Split(Sfixed64ValueStr, ",")
	for _, str := range Sfixed64ValueStrs {
		Sfixed64Value, convErr := strconv.ParseInt(str, 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", convErr)
		}
		arg.Sfixed64Value = append(arg.Sfixed64Value, Sfixed64Value)
	}
	Fixed64ValueStr := r.PathValue("Fixed64Value")
	if len(Fixed64ValueStr) == 0 {
		return nil, errors.New("empty value for parameter Fixed64Value")
	}
	Fixed64ValueStrs := strings.Split(Fixed64ValueStr, ",")
	for _, str := range Fixed64ValueStrs {
		Fixed64Value, convErr := strconv.ParseUint(str, 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
		}
		arg.Fixed64Value = append(arg.Fixed64Value, Fixed64Value)
	}
	DoubleValueStr := r.PathValue("DoubleValue")
	if len(DoubleValueStr) == 0 {
		return nil, errors.New("empty value for parameter DoubleValue")
	}
	DoubleValueStrs := strings.Split(DoubleValueStr, ",")
	for _, str := range DoubleValueStrs {
		DoubleValue, convErr := strconv.ParseFloat(str, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter DoubleValue: %w", convErr)
		}
		arg.DoubleValue = append(arg.DoubleValue, DoubleValue)
	}
	StringValueStr := r.PathValue("StringValue")
	if len(StringValueStr) == 0 {
		return nil, errors.New("empty value for parameter StringValue")
	}
	arg.StringValue = strings.Split(StringValueStr, ",")
	BytesValueStr := r.PathValue("BytesValue")
	if len(BytesValueStr) == 0 {
		return nil, errors.New("empty value for parameter BytesValue")
	}
	arg.BytesValue = append(arg.BytesValue, []byte(BytesValueStr))
	StringValueQueryStr := r.PathValue("StringValueQuery")
	if len(StringValueQueryStr) == 0 {
		return nil, errors.New("empty value for parameter StringValueQuery")
	}
	arg.StringValueQuery = strings.Split(StringValueQueryStr, ",")
	return arg, err
}

func buildExampleServiceNameCheckRepeatedQueryRepeatedCheck(r *http.Request) (arg *common.RepeatedCheck, err error) {
	arg = &common.RepeatedCheck{}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "BoolValue[]":
			switch value {
			case "true", "t", "1":
				arg.BoolValue = append(arg.BoolValue, true)
			case "false", "f", "0":
				arg.BoolValue = append(arg.BoolValue, false)
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "EnumValue[]":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.EnumValue = append(arg.EnumValue, common.Options(OptionsValue))
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.EnumValue = append(arg.EnumValue, common.Options(intOptionValue))
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
					return
				}
			}
		case "Int32Value[]":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			arg.Int32Value = append(arg.Int32Value, int32(Int32Value))
		case "Sint32Value[]":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			arg.Sint32Value = append(arg.Sint32Value, int32(Sint32Value))
		case "Uint32Value[]":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			arg.Uint32Value = append(arg.Uint32Value, uint32(Uint32Value))
		case "Int64Value[]":
			Int64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", convErr)
				return
			}
			arg.Int64Value = append(arg.Int64Value, Int64Value)
		case "Sint64Value[]":
			Sint64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
				return
			}
			arg.Sint64Value = append(arg.Sint64Value, Sint64Value)
		case "Uint64Value[]":
			Uint64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", convErr)
				return
			}
			arg.Uint64Value = append(arg.Uint64Value, Uint64Value)
		case "Sfixed32Value[]":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			arg.Sfixed32Value = append(arg.Sfixed32Value, int32(Sfixed32Value))
		case "Fixed32Value[]":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			arg.Fixed32Value = append(arg.Fixed32Value, uint32(Fixed32Value))
		case "FloatValue[]":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			arg.FloatValue = append(arg.FloatValue, float32(FloatValue))
		case "Sfixed64Value[]":
			Sfixed64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", convErr)
				return
			}
			arg.Sfixed64Value = append(arg.Sfixed64Value, Sfixed64Value)
		case "Fixed64Value[]":
			Fixed64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
				return
			}
			arg.Fixed64Value = append(arg.Fixed64Value, Fixed64Value)
		case "DoubleValue[]":
			DoubleValue, convErr := strconv.ParseFloat(value, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", convErr)
				return
			}
			arg.DoubleValue = append(arg.DoubleValue, DoubleValue)
		case "StringValue[]":
			arg.StringValue = append(arg.StringValue, value)
		case "BytesValue[]":
			arg.BytesValue = append(arg.BytesValue, []byte(value))
		case "StringValueQuery[]":
			arg.StringValueQuery = append(arg.StringValueQuery, value)
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	StringValueStr := r.PathValue("StringValue")
	if len(StringValueStr) == 0 {
		return nil, errors.New("empty value for parameter StringValue")
	}
	arg.StringValue = strings.Split(StringValueStr, ",")
	return arg, err
}

func buildExampleServiceNameCheckRepeatedPostRepeatedCheck(r *http.Request) (arg *common.RepeatedCheck, err error) {
	arg = &common.RepeatedCheck{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "BoolValue[]":
			switch value {
			case "true", "t", "1":
				arg.BoolValue = append(arg.BoolValue, true)
			case "false", "f", "0":
				arg.BoolValue = append(arg.BoolValue, false)
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "EnumValue[]":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.EnumValue = append(arg.EnumValue, common.Options(OptionsValue))
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.EnumValue = append(arg.EnumValue, common.Options(intOptionValue))
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
					return
				}
			}
		case "Int32Value[]":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			arg.Int32Value = append(arg.Int32Value, int32(Int32Value))
		case "Sint32Value[]":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			arg.Sint32Value = append(arg.Sint32Value, int32(Sint32Value))
		case "Uint32Value[]":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			arg.Uint32Value = append(arg.Uint32Value, uint32(Uint32Value))
		case "Int64Value[]":
			Int64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", convErr)
				return
			}
			arg.Int64Value = append(arg.Int64Value, Int64Value)
		case "Sint64Value[]":
			Sint64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
				return
			}
			arg.Sint64Value = append(arg.Sint64Value, Sint64Value)
		case "Uint64Value[]":
			Uint64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", convErr)
				return
			}
			arg.Uint64Value = append(arg.Uint64Value, Uint64Value)
		case "Sfixed32Value[]":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			arg.Sfixed32Value = append(arg.Sfixed32Value, int32(Sfixed32Value))
		case "Fixed32Value[]":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			arg.Fixed32Value = append(arg.Fixed32Value, uint32(Fixed32Value))
		case "FloatValue[]":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			arg.FloatValue = append(arg.FloatValue, float32(FloatValue))
		case "Sfixed64Value[]":
			Sfixed64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", convErr)
				return
			}
			arg.Sfixed64Value = append(arg.Sfixed64Value, Sfixed64Value)
		case "Fixed64Value[]":
			Fixed64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
				return
			}
			arg.Fixed64Value = append(arg.Fixed64Value, Fixed64Value)
		case "DoubleValue[]":
			DoubleValue, convErr := strconv.ParseFloat(value, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", convErr)
				return
			}
			arg.DoubleValue = append(arg.DoubleValue, DoubleValue)
		case "StringValue[]":
			arg.StringValue = append(arg.StringValue, value)
		case "BytesValue[]":
			arg.BytesValue = append(arg.BytesValue, []byte(value))
		case "StringValueQuery[]":
			arg.StringValueQuery = append(arg.StringValueQuery, value)
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	StringValueStr := r.PathValue("StringValue")
	if len(StringValueStr) == 0 {
		return nil, errors.New("empty value for parameter StringValue")
	}
	arg.StringValue = strings.Split(StringValueStr, ",")
	return arg, err
}

func buildExampleServiceNameEmptyGetEmpty(r *http.Request) (arg *common.Empty, err error) {
	arg = &common.Empty{}
	return arg, err
}

func buildExampleServiceNameEmptyPostEmpty(r *http.Request) (arg *common.Empty, err error) {
	arg = &common.Empty{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	return arg, err
}

func buildExampleServiceNameTopLevelArrayEmpty(r *http.Request) (arg *common.Empty, err error) {
	arg = &common.Empty{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	return arg, err
}

func buildExampleServiceNameOnlyStructInGetOnlyStruct(r *http.Request) (arg *common.OnlyStruct, err error) {
	arg = &common.OnlyStruct{}
	var body []byte
	if body, err = io.ReadAll(r.Body); err != nil {
		return nil, err
	}
	_ = r.Body.Close()
	if len(body) > 0 {
		if argEJ, ok := interface{}(arg).(easyjson.Unmarshaler); ok {
			if err = easyjson.Unmarshal(body, argEJ); err != nil {
				return nil, err
			}
		} else {
			if err = json.Unmarshal(body, arg); err != nil {
				return nil, err
			}
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "value":
			err = fmt.Errorf("unsupported type message for query argument value")
			return
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	return arg, err
}

func buildExampleServiceNameMultipartFormMultipartFormRequest(r *http.Request) (arg *common.MultipartFormRequest, err error) {
	arg = &common.MultipartFormRequest{}
	r.ParseMultipartForm(32 << 20)
	f, fh, err := r.FormFile("document")
	if err == nil && !errors.Is(err, http.ErrMissingFile) {
		arg.Document = &common.FileEx{
			File:    make([]byte, fh.Size),
			Name:    fh.Filename,
			Headers: make(map[string]string, len(fh.Header)),
		}
		for key, value := range fh.Header {
			arg.Document.Headers[key] = value[0]
		}
		_, err = f.Read(arg.Document.File)
		if err != nil {
			return nil, fmt.Errorf("failed to read file: document: %w", err)
		}
	}
	if values := r.Form["otherField"]; len(values) > 0 {
		arg.OtherField = values[0]
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "document":
			err = fmt.Errorf("unsupported type message for query argument document")
			return
		case "otherField":
			arg.OtherField = value
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	return arg, err
}

func buildExampleServiceNameMultipartFormAllTypesMultipartFormAllTypes(r *http.Request) (arg *common.MultipartFormAllTypes, err error) {
	arg = &common.MultipartFormAllTypes{}
	r.ParseMultipartForm(32 << 20)
	if values := r.Form["BoolValue"]; len(values) > 0 {
		switch values[0] {
		case "true", "t", "1":
			arg.BoolValue = true
		case "false", "f", "0":
			arg.BoolValue = false
		default:
			return nil, fmt.Errorf("unknown bool string value %s", values[0])
		}
	}
	if values := r.Form["EnumValue"]; len(values) > 0 {
		if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(values[0])]; optValueOk {
			arg.EnumValue = common.Options(OptionsValue)
		} else {
			if intOptionValue, convErr := strconv.ParseInt(values[0], 10, 32); convErr == nil {
				if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
					arg.EnumValue = common.Options(intOptionValue)
				}
			} else {
				return nil, fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
			}
		}
	}
	if values := r.Form["Int32Value"]; len(values) > 0 {
		Int32Value, convErr := strconv.ParseInt(values[0], 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
		}
		arg.Int32Value = int32(Int32Value)
	}
	if values := r.Form["Sint32Value"]; len(values) > 0 {
		Sint32Value, convErr := strconv.ParseInt(values[0], 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
		}
		arg.Sint32Value = int32(Sint32Value)
	}
	if values := r.Form["Uint32Value"]; len(values) > 0 {
		for _, value := range values {
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				return nil, fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
			}
			arg.Uint32Value = append(arg.Uint32Value, uint32(Uint32Value))
		}
	}
	if values := r.Form["Int64Value"]; len(values) > 0 {
		arg.Int64Value, err = strconv.ParseInt(values[0], 10, 64)
		if err != nil {
			return nil, fmt.Errorf("conversion failed for parameter Int64Value: %w", err)
		}
	}
	if values := r.Form["Sint64Value"]; len(values) > 0 {
		Sint64Value, convErr := strconv.ParseInt(values[0], 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
		}
		arg.Sint64Value = &Sint64Value
	}
	if values := r.Form["Uint64Value"]; len(values) > 0 {
		arg.Uint64Value, err = strconv.ParseUint(values[0], 10, 64)
		if err != nil {
			return nil, fmt.Errorf("conversion failed for parameter Uint64Value: %w", err)
		}
	}
	if values := r.Form["Sfixed32Value"]; len(values) > 0 {
		Sfixed32Value, convErr := strconv.ParseInt(values[0], 10, 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
		}
		arg.Sfixed32Value = int32(Sfixed32Value)
	}
	if values := r.Form["Fixed32Value"]; len(values) > 0 {
		for _, value := range values {
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				return nil, fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
			}
			arg.Fixed32Value = append(arg.Fixed32Value, uint32(Fixed32Value))
		}
	}
	if values := r.Form["FloatValue"]; len(values) > 0 {
		FloatValue, convErr := strconv.ParseFloat(values[0], 32)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
		}
		arg.FloatValue = float32(FloatValue)
	}
	if values := r.Form["Sfixed64Value"]; len(values) > 0 {
		arg.Sfixed64Value, err = strconv.ParseInt(values[0], 10, 64)
		if err != nil {
			return nil, fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", err)
		}
	}
	if values := r.Form["Fixed64Value"]; len(values) > 0 {
		Fixed64Value, convErr := strconv.ParseUint(values[0], 10, 64)
		if convErr != nil {
			return nil, fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
		}
		arg.Fixed64Value = &Fixed64Value
	}
	if values := r.Form["DoubleValue"]; len(values) > 0 {
		arg.DoubleValue, err = strconv.ParseFloat(values[0], 64)
		if err != nil {
			return nil, fmt.Errorf("conversion failed for parameter DoubleValue: %w", err)
		}
	}
	if values := r.Form["StringValue"]; len(values) > 0 {
		arg.StringValue = values[0]
	}
	if values := r.Form["BytesValue"]; len(values) > 0 {
		arg.BytesValue = []byte(values[0])
	}
	if values := r.Form["SliceStringValue"]; len(values) > 0 {
		for _, value := range values {
			arg.SliceStringValue = append(arg.SliceStringValue, value)
		}
	}
	if values := r.Form["SliceInt32Value"]; len(values) > 0 {
		for _, value := range values {
			SliceInt32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				return nil, fmt.Errorf("conversion failed for parameter SliceInt32Value: %w", convErr)
			}
			arg.SliceInt32Value = append(arg.SliceInt32Value, int32(SliceInt32Value))
		}
	}
	f, fh, err := r.FormFile("document")
	if err == nil && !errors.Is(err, http.ErrMissingFile) {
		arg.Document = &common.FileEx{
			File:    make([]byte, fh.Size),
			Name:    fh.Filename,
			Headers: make(map[string]string, len(fh.Header)),
		}
		for key, value := range fh.Header {
			arg.Document.Headers[key] = value[0]
		}
		_, err = f.Read(arg.Document.File)
		if err != nil {
			return nil, fmt.Errorf("failed to read file: document: %w", err)
		}
	}
	if values := r.Form["RepeatedStringValue"]; len(values) > 0 {
		for _, value := range values {
			arg.RepeatedStringValue = append(arg.RepeatedStringValue, value)
		}
	}
	for key, values := range r.URL.Query() {
		var value = values[0]
		switch key {
		case "BoolValue":
			switch value {
			case "true", "t", "1":
				arg.BoolValue = true
			case "false", "f", "0":
				arg.BoolValue = false
			default:
				err = fmt.Errorf("unknown bool string value %s", value)
				return
			}
		case "EnumValue":
			if OptionsValue, optValueOk := common.Options_value[strings.ToUpper(value)]; optValueOk {
				arg.EnumValue = common.Options(OptionsValue)
			} else {
				if intOptionValue, convErr := strconv.ParseInt(value, 10, 32); convErr == nil {
					if _, optIntValueOk := common.Options_name[int32(intOptionValue)]; optIntValueOk {
						arg.EnumValue = common.Options(intOptionValue)
					}
				} else {
					err = fmt.Errorf("conversion failed for parameter EnumValue: %w", convErr)
					return
				}
			}
		case "Int32Value":
			Int32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Int32Value: %w", convErr)
				return
			}
			arg.Int32Value = int32(Int32Value)
		case "Sint32Value":
			Sint32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint32Value: %w", convErr)
				return
			}
			arg.Sint32Value = int32(Sint32Value)
		case "Uint32Value[]":
			Uint32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Uint32Value: %w", convErr)
				return
			}
			arg.Uint32Value = append(arg.Uint32Value, uint32(Uint32Value))
		case "Int64Value":
			arg.Int64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Int64Value: %w", err)
				return
			}
		case "Sint64Value":
			Sint64Value, convErr := strconv.ParseInt(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sint64Value: %w", convErr)
				return
			}
			arg.Sint64Value = &Sint64Value
		case "Uint64Value":
			arg.Uint64Value, err = strconv.ParseUint(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Uint64Value: %w", err)
				return
			}
		case "Sfixed32Value":
			Sfixed32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed32Value: %w", convErr)
				return
			}
			arg.Sfixed32Value = int32(Sfixed32Value)
		case "Fixed32Value[]":
			Fixed32Value, convErr := strconv.ParseUint(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed32Value: %w", convErr)
				return
			}
			arg.Fixed32Value = append(arg.Fixed32Value, uint32(Fixed32Value))
		case "FloatValue":
			FloatValue, convErr := strconv.ParseFloat(value, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter FloatValue: %w", convErr)
				return
			}
			arg.FloatValue = float32(FloatValue)
		case "Sfixed64Value":
			arg.Sfixed64Value, err = strconv.ParseInt(value, 10, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter Sfixed64Value: %w", err)
				return
			}
		case "Fixed64Value":
			Fixed64Value, convErr := strconv.ParseUint(value, 10, 64)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter Fixed64Value: %w", convErr)
				return
			}
			arg.Fixed64Value = &Fixed64Value
		case "DoubleValue":
			arg.DoubleValue, err = strconv.ParseFloat(value, 64)
			if err != nil {
				err = fmt.Errorf("conversion failed for parameter DoubleValue: %w", err)
				return
			}
		case "StringValue":
			arg.StringValue = value
		case "BytesValue":
			arg.BytesValue = []byte(value)
		case "SliceStringValue[]":
			arg.SliceStringValue = append(arg.SliceStringValue, value)
		case "SliceInt32Value[]":
			SliceInt32Value, convErr := strconv.ParseInt(value, 10, 32)
			if convErr != nil {
				err = fmt.Errorf("conversion failed for parameter SliceInt32Value: %w", convErr)
				return
			}
			arg.SliceInt32Value = append(arg.SliceInt32Value, int32(SliceInt32Value))
		case "document":
			err = fmt.Errorf("unsupported type message for query argument document")
			return
		case "RepeatedStringValue[]":
			arg.RepeatedStringValue = append(arg.RepeatedStringValue, value)
		default:
			err = fmt.Errorf("unknown query parameter %s with value %s", key, value)
			return
		}
	}
	return arg, err
}

func chainServerMiddlewaresExample(
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error),
) func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error) {
	switch len(middlewares) {
	case 0:
		return nil
	case 1:
		return middlewares[0]
	default:
		return func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error) {
			return middlewares[0](ctx, req, getChainServerMiddlewareHandlerExample(middlewares, 0, handler))
		}
	}
}

func getChainServerMiddlewareHandlerExample(
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error),
	curr int,
	finalHandler func(ctx context.Context, req interface{}) (resp interface{}, err error),
) func(ctx context.Context, req interface{}) (resp interface{}, err error) {
	if curr == len(middlewares)-1 {
		return finalHandler
	}
	return func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		return middlewares[curr+1](ctx, req, getChainServerMiddlewareHandlerExample(middlewares, curr+1, finalHandler))
	}
}

var _ ServiceNameHTTPGoService = &ServiceNameHTTPGoClient{}

type ServiceNameHTTPGoClient struct {
	cl          *http.Client
	host        string
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error)
	middleware  func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error)
}

func GetServiceNameHTTPGoClient(
	_ context.Context,
	cl *http.Client,
	host string,
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error),
) (*ServiceNameHTTPGoClient, error) {
	return &ServiceNameHTTPGoClient{
		cl:          cl,
		host:        host,
		middlewares: middlewares,
		middleware:  chainClientMiddlewaresExample(middlewares),
	}, nil
}

func (p *ServiceNameHTTPGoClient) RPCName(ctx context.Context, request *common.InputMsgName) (resp *common.OutputMsgName, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/test/%s/%d%s", p.host, request.StringArgument, request.Int64Argument, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "RPCName")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.OutputMsgName{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) AllTypesTest(ctx context.Context, request *common.AllTypesMsg) (resp *common.AllTypesMsg, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/test/%t/%s/%d/%d/%d/%d/%d/%d/%d/%d/%f/%d/%d/%f/%s/%s%s", p.host, request.BoolValue, request.EnumValue, request.Int32Value, request.Sint32Value, request.Uint32Value, request.Int64Value, request.Sint64Value, request.Uint64Value, request.Sfixed32Value, request.Fixed32Value, request.FloatValue, request.Sfixed64Value, request.Fixed64Value, request.DoubleValue, request.StringValue, request.BytesValue, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "AllTypesTest")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.AllTypesMsg{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) AllTextTypesPost(ctx context.Context, request *common.AllTextTypesMsg) (resp *common.AllTextTypesMsg, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	RepeatedStringRequest := strings.Join(request.RepeatedString, ",")
	RepeatedBytesStrs := make([]string, len(request.RepeatedBytes))
	for i, v := range request.RepeatedBytes {
		RepeatedBytesStrs[i] = string(v)
	}
	RepeatedBytesRequest := strings.Join(RepeatedBytesStrs, ",")
	RepeatedEnumStrs := make([]string, len(request.RepeatedEnum))
	for i, v := range request.RepeatedEnum {
		RepeatedEnumStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	RepeatedEnumRequest := strings.Join(RepeatedEnumStrs, ",")
	u, err := url.Parse(fmt.Sprintf("%s/v1/text/%s/%s/%s/%s/%s/%s%s", p.host, request.String_, RepeatedStringRequest, request.Bytes, RepeatedBytesRequest, request.Enum, RepeatedEnumRequest, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "AllTextTypesPost")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.AllTextTypesMsg{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) AllTextTypesGet(ctx context.Context, request *common.AllTextTypesMsg) (resp *common.AllTextTypesMsg, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var parameters = []string{}
	var values = []interface{}{}
	if request.OptionalString != nil {
		parameters = append(parameters, "OptionalString=%s")
		values = append(values, *request.OptionalString)
	}
	if request.OptionalBytes != nil {
		parameters = append(parameters, "OptionalBytes=%s")
		values = append(values, request.OptionalBytes)
	}
	if request.OptionalEnum != nil {
		parameters = append(parameters, "OptionalEnum=%s")
		values = append(values, *request.OptionalEnum)
	}
	queryArgs = fmt.Sprintf("?"+strings.Join(parameters, "&"), values...)
	RepeatedStringRequest := strings.Join(request.RepeatedString, ",")
	RepeatedBytesStrs := make([]string, len(request.RepeatedBytes))
	for i, v := range request.RepeatedBytes {
		RepeatedBytesStrs[i] = string(v)
	}
	RepeatedBytesRequest := strings.Join(RepeatedBytesStrs, ",")
	RepeatedEnumStrs := make([]string, len(request.RepeatedEnum))
	for i, v := range request.RepeatedEnum {
		RepeatedEnumStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	RepeatedEnumRequest := strings.Join(RepeatedEnumStrs, ",")
	u, err := url.Parse(fmt.Sprintf("%s/v2/text/%s/%s/%s/%s/%s/%s%s", p.host, request.String_, RepeatedStringRequest, request.Bytes, RepeatedBytesRequest, request.Enum, RepeatedEnumRequest, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodGet
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "AllTextTypesGet")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.AllTextTypesMsg{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) CommonTypes(ctx context.Context, request *anypb.Any) (resp *emptypb.Empty, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/test/commonTypes%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "CommonTypes")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &emptypb.Empty{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

// SameInputAndOutput same types but different query, we need different query builder function
func (p *ServiceNameHTTPGoClient) SameInputAndOutput(ctx context.Context, request *common.InputMsgName) (resp *common.OutputMsgName, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/test/%s%s", p.host, request.StringArgument, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "SameInputAndOutput")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.OutputMsgName{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) Optional(ctx context.Context, request *common.OptionalField) (resp *common.OptionalField, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/test/optional%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "Optional")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.OptionalField{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) GetMethod(ctx context.Context, request *common.InputMsgName) (resp *common.OutputMsgName, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var parameters = []string{
		"int64Argument=%d",
		"stringArgument=%s",
	}
	var values = []interface{}{
		request.Int64Argument,
		request.StringArgument,
	}
	queryArgs = fmt.Sprintf("?"+strings.Join(parameters, "&"), values...)
	u, err := url.Parse(fmt.Sprintf("%s/v1/test/get%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodGet
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "GetMethod")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.OutputMsgName{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) CheckRepeatedPath(ctx context.Context, request *common.RepeatedCheck) (resp *common.RepeatedCheck, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	BoolValueStrs := make([]string, len(request.BoolValue))
	for i, v := range request.BoolValue {
		BoolValueStrs[i] = strconv.FormatBool(v)
	}
	BoolValueRequest := strings.Join(BoolValueStrs, ",")
	EnumValueStrs := make([]string, len(request.EnumValue))
	for i, v := range request.EnumValue {
		EnumValueStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	EnumValueRequest := strings.Join(EnumValueStrs, ",")
	Int32ValueStrs := make([]string, len(request.Int32Value))
	for i, v := range request.Int32Value {
		Int32ValueStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	Int32ValueRequest := strings.Join(Int32ValueStrs, ",")
	Sint32ValueStrs := make([]string, len(request.Sint32Value))
	for i, v := range request.Sint32Value {
		Sint32ValueStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	Sint32ValueRequest := strings.Join(Sint32ValueStrs, ",")
	Uint32ValueStrs := make([]string, len(request.Uint32Value))
	for i, v := range request.Uint32Value {
		Uint32ValueStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	Uint32ValueRequest := strings.Join(Uint32ValueStrs, ",")
	Int64ValueStrs := make([]string, len(request.Int64Value))
	for i, v := range request.Int64Value {
		Int64ValueStrs[i] = strconv.FormatInt(v, 10)
	}
	Int64ValueRequest := strings.Join(Int64ValueStrs, ",")
	Sint64ValueStrs := make([]string, len(request.Sint64Value))
	for i, v := range request.Sint64Value {
		Sint64ValueStrs[i] = strconv.FormatInt(v, 10)
	}
	Sint64ValueRequest := strings.Join(Sint64ValueStrs, ",")
	Uint64ValueStrs := make([]string, len(request.Uint64Value))
	for i, v := range request.Uint64Value {
		Uint64ValueStrs[i] = strconv.FormatUint(v, 10)
	}
	Uint64ValueRequest := strings.Join(Uint64ValueStrs, ",")
	Sfixed32ValueStrs := make([]string, len(request.Sfixed32Value))
	for i, v := range request.Sfixed32Value {
		Sfixed32ValueStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	Sfixed32ValueRequest := strings.Join(Sfixed32ValueStrs, ",")
	Fixed32ValueStrs := make([]string, len(request.Fixed32Value))
	for i, v := range request.Fixed32Value {
		Fixed32ValueStrs[i] = strconv.FormatInt(int64(v), 10)
	}
	Fixed32ValueRequest := strings.Join(Fixed32ValueStrs, ",")
	FloatValueStrs := make([]string, len(request.FloatValue))
	for i, v := range request.FloatValue {
		FloatValueStrs[i] = strconv.FormatFloat(float64(v), 'f', -1, 64)
	}
	FloatValueRequest := strings.Join(FloatValueStrs, ",")
	Sfixed64ValueStrs := make([]string, len(request.Sfixed64Value))
	for i, v := range request.Sfixed64Value {
		Sfixed64ValueStrs[i] = strconv.FormatInt(v, 10)
	}
	Sfixed64ValueRequest := strings.Join(Sfixed64ValueStrs, ",")
	Fixed64ValueStrs := make([]string, len(request.Fixed64Value))
	for i, v := range request.Fixed64Value {
		Fixed64ValueStrs[i] = strconv.FormatUint(v, 10)
	}
	Fixed64ValueRequest := strings.Join(Fixed64ValueStrs, ",")
	DoubleValueStrs := make([]string, len(request.DoubleValue))
	for i, v := range request.DoubleValue {
		DoubleValueStrs[i] = strconv.FormatFloat(v, 'f', -1, 64)
	}
	DoubleValueRequest := strings.Join(DoubleValueStrs, ",")
	StringValueRequest := strings.Join(request.StringValue, ",")
	BytesValueStrs := make([]string, len(request.BytesValue))
	for i, v := range request.BytesValue {
		BytesValueStrs[i] = string(v)
	}
	BytesValueRequest := strings.Join(BytesValueStrs, ",")
	StringValueQueryRequest := strings.Join(request.StringValueQuery, ",")
	u, err := url.Parse(fmt.Sprintf("%s/v1/repeated/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s/%s%s", p.host, BoolValueRequest, EnumValueRequest, Int32ValueRequest, Sint32ValueRequest, Uint32ValueRequest, Int64ValueRequest, Sint64ValueRequest, Uint64ValueRequest, Sfixed32ValueRequest, Fixed32ValueRequest, FloatValueRequest, Sfixed64ValueRequest, Fixed64ValueRequest, DoubleValueRequest, StringValueRequest, BytesValueRequest, StringValueQueryRequest, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodGet
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "CheckRepeatedPath")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.RepeatedCheck{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) CheckRepeatedQuery(ctx context.Context, request *common.RepeatedCheck) (resp *common.RepeatedCheck, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var parameters = []string{}
	var values = []interface{}{}
	for _, v := range request.BoolValue {
		parameters = append(parameters, "BoolValue[]=%t")
		values = append(values, v)
	}
	for _, v := range request.EnumValue {
		parameters = append(parameters, "EnumValue[]=%s")
		values = append(values, v)
	}
	for _, v := range request.Int32Value {
		parameters = append(parameters, "Int32Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Sint32Value {
		parameters = append(parameters, "Sint32Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Uint32Value {
		parameters = append(parameters, "Uint32Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Int64Value {
		parameters = append(parameters, "Int64Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Sint64Value {
		parameters = append(parameters, "Sint64Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Uint64Value {
		parameters = append(parameters, "Uint64Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Sfixed32Value {
		parameters = append(parameters, "Sfixed32Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Fixed32Value {
		parameters = append(parameters, "Fixed32Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.FloatValue {
		parameters = append(parameters, "FloatValue[]=%f")
		values = append(values, v)
	}
	for _, v := range request.Sfixed64Value {
		parameters = append(parameters, "Sfixed64Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.Fixed64Value {
		parameters = append(parameters, "Fixed64Value[]=%d")
		values = append(values, v)
	}
	for _, v := range request.DoubleValue {
		parameters = append(parameters, "DoubleValue[]=%f")
		values = append(values, v)
	}
	for _, v := range request.BytesValue {
		parameters = append(parameters, "BytesValue[]=%s")
		values = append(values, v)
	}
	for _, v := range request.StringValueQuery {
		parameters = append(parameters, "StringValueQuery[]=%s")
		values = append(values, v)
	}
	queryArgs = fmt.Sprintf("?"+strings.Join(parameters, "&"), values...)
	StringValueRequest := strings.Join(request.StringValue, ",")
	u, err := url.Parse(fmt.Sprintf("%s/v1/repeated/%s%s", p.host, StringValueRequest, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodGet
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "CheckRepeatedQuery")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.RepeatedCheck{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) CheckRepeatedPost(ctx context.Context, request *common.RepeatedCheck) (resp *common.RepeatedCheck, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	StringValueRequest := strings.Join(request.StringValue, ",")
	u, err := url.Parse(fmt.Sprintf("%s/v1/repeated/%s%s", p.host, StringValueRequest, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "CheckRepeatedPost")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.RepeatedCheck{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) EmptyGet(ctx context.Context, request *common.Empty) (resp *common.Empty, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	u, err := url.Parse(fmt.Sprintf("%s/v1/emptyGet%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodGet
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "EmptyGet")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.Empty{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) EmptyPost(ctx context.Context, request *common.Empty) (resp *common.Empty, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/emptyPost%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "EmptyPost")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.Empty{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) TopLevelArray(ctx context.Context, request *common.Empty) (resp *common.Array, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/array%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "TopLevelArray")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.Array{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp.Items).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, &resp.Items); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) OnlyStructInGet(ctx context.Context, request *common.OnlyStruct) (resp *common.Empty, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var body []byte
	if rqEJ, ok := interface{}(request).(easyjson.Marshaler); ok {
		body, err = easyjson.Marshal(rqEJ)
	} else {
		body, err = json.Marshal(request)
	}
	if err != nil {
		return nil, err
	}
	req.Body = io.NopCloser(bytes.NewBuffer(body))
	u, err := url.Parse(fmt.Sprintf("%s/v1/onlyStruct%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "OnlyStructInGet")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.Empty{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) MultipartForm(ctx context.Context, request *common.MultipartFormRequest) (resp *common.Empty, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)
	part, err := writer.CreateFormFile("document", request.Document.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to create form file document:  %w", err)
	}
	if _, err = part.Write(request.Document.File); err != nil {
		return nil, fmt.Errorf("failed to write data to part document: %w", err)
	}
	if err = writer.WriteField("otherField", request.OtherField); err != nil {
		return nil, fmt.Errorf("failed to write field otherField:  %w", err)
	}
	if err = writer.Close(); err != nil {
		return nil, fmt.Errorf("failed to close writer: %w", err)
	}
	req.Body = io.NopCloser(bytes.NewBuffer(requestBody.Bytes()))
	u, err := url.Parse(fmt.Sprintf("%s/v1/multipart%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "MultipartForm")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.Empty{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func (p *ServiceNameHTTPGoClient) MultipartFormAllTypes(ctx context.Context, request *common.MultipartFormAllTypes) (resp *common.Empty, err error) {
	req := &http.Request{Header: make(http.Header)}
	var queryArgs string
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)
	if err = writer.WriteField("BoolValue", strconv.FormatBool(request.BoolValue)); err != nil {
		return nil, fmt.Errorf("failed to write field BoolValue:  %w", err)
	}
	if err = writer.WriteField("EnumValue", strconv.FormatInt(int64(request.EnumValue), 10)); err != nil {
		return nil, fmt.Errorf("failed to write field EnumValue:  %w", err)
	}
	if err = writer.WriteField("Int32Value", strconv.FormatInt(int64(request.Int32Value), 10)); err != nil {
		return nil, fmt.Errorf("failed to write field Int32Value:  %w", err)
	}
	if err = writer.WriteField("Sint32Value", strconv.FormatInt(int64(request.Sint32Value), 10)); err != nil {
		return nil, fmt.Errorf("failed to write field Sint32Value:  %w", err)
	}
	for _, value := range request.Uint32Value {
		if err = writer.WriteField("Uint32Value", strconv.FormatInt(int64(value), 10)); err != nil {
			return nil, fmt.Errorf("failed to write field Uint32Value:  %w", err)
		}
	}
	if err = writer.WriteField("Int64Value", strconv.FormatInt(request.Int64Value, 10)); err != nil {
		return nil, fmt.Errorf("failed to write field Int64Value:  %w", err)
	}
	if request.Sint64Value != nil {
		if err = writer.WriteField("Sint64Value", strconv.FormatInt(*request.Sint64Value, 10)); err != nil {
			return nil, fmt.Errorf("failed to write field Sint64Value:  %w", err)
		}
	}
	if err = writer.WriteField("Uint64Value", strconv.FormatUint(request.Uint64Value, 10)); err != nil {
		return nil, fmt.Errorf("failed to write field Uint64Value:  %w", err)
	}
	if err = writer.WriteField("Sfixed32Value", strconv.FormatInt(int64(request.Sfixed32Value), 10)); err != nil {
		return nil, fmt.Errorf("failed to write field Sfixed32Value:  %w", err)
	}
	for _, value := range request.Fixed32Value {
		if err = writer.WriteField("Fixed32Value", strconv.FormatInt(int64(value), 10)); err != nil {
			return nil, fmt.Errorf("failed to write field Fixed32Value:  %w", err)
		}
	}
	if err = writer.WriteField("FloatValue", strconv.FormatFloat(float64(request.FloatValue), 'f', -1, 64)); err != nil {
		return nil, fmt.Errorf("failed to write field FloatValue:  %w", err)
	}
	if err = writer.WriteField("Sfixed64Value", strconv.FormatInt(request.Sfixed64Value, 10)); err != nil {
		return nil, fmt.Errorf("failed to write field Sfixed64Value:  %w", err)
	}
	if request.Fixed64Value != nil {
		if err = writer.WriteField("Fixed64Value", strconv.FormatUint(*request.Fixed64Value, 10)); err != nil {
			return nil, fmt.Errorf("failed to write field Fixed64Value:  %w", err)
		}
	}
	if err = writer.WriteField("DoubleValue", strconv.FormatFloat(request.DoubleValue, 'f', -1, 64)); err != nil {
		return nil, fmt.Errorf("failed to write field DoubleValue:  %w", err)
	}
	if err = writer.WriteField("StringValue", request.StringValue); err != nil {
		return nil, fmt.Errorf("failed to write field StringValue:  %w", err)
	}
	if err = writer.WriteField("BytesValue", string(request.BytesValue)); err != nil {
		return nil, fmt.Errorf("failed to write field BytesValue:  %w", err)
	}
	for _, value := range request.SliceStringValue {
		if err = writer.WriteField("SliceStringValue", value); err != nil {
			return nil, fmt.Errorf("failed to write field SliceStringValue:  %w", err)
		}
	}
	for _, value := range request.SliceInt32Value {
		if err = writer.WriteField("SliceInt32Value", strconv.FormatInt(int64(value), 10)); err != nil {
			return nil, fmt.Errorf("failed to write field SliceInt32Value:  %w", err)
		}
	}
	part, err := writer.CreateFormFile("document", request.Document.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to create form file document:  %w", err)
	}
	if _, err = part.Write(request.Document.File); err != nil {
		return nil, fmt.Errorf("failed to write data to part document: %w", err)
	}
	for _, value := range request.RepeatedStringValue {
		if err = writer.WriteField("RepeatedStringValue", value); err != nil {
			return nil, fmt.Errorf("failed to write field RepeatedStringValue:  %w", err)
		}
	}
	if err = writer.Close(); err != nil {
		return nil, fmt.Errorf("failed to close writer: %w", err)
	}
	req.Body = io.NopCloser(bytes.NewBuffer(requestBody.Bytes()))
	u, err := url.Parse(fmt.Sprintf("%s/v1/multipartall%s", p.host, queryArgs))
	if err != nil {
		return nil, err
	}
	req.URL = u
	req.Method = http.MethodPost
	var reqResp interface{}
	ctx = context.WithValue(ctx, "proto_service", "ServiceName")
	ctx = context.WithValue(ctx, "proto_method", "MultipartFormAllTypes")
	var handler = func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		resp, err = p.cl.Do(req.(*http.Request))
		return resp, err
	}
	if p.middleware == nil {
		if reqResp, err = handler(ctx, req); err != nil {
			return nil, err
		}
	} else {
		if reqResp, err = p.middleware(ctx, req, handler); err != nil {
			return nil, err
		}
	}
	resp = &common.Empty{}
	var respBody []byte
	if respBody, err = io.ReadAll(reqResp.(*http.Response).Body); err != nil {
		return nil, err
	}
	_ = reqResp.(*http.Response).Body.Close()
	if respEJ, ok := interface{}(resp).(easyjson.Unmarshaler); ok {
		if err = easyjson.Unmarshal(respBody, respEJ); err != nil {
			return nil, err
		}
	} else {
		if err = json.Unmarshal(respBody, resp); err != nil {
			return nil, err
		}
	}
	return resp, err
}

func chainClientMiddlewaresExample(
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error),
) func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error) {
	switch len(middlewares) {
	case 0:
		return nil
	case 1:
		return middlewares[0]
	default:
		return func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error) {
			return middlewares[0](ctx, req, getChainClientMiddlewareHandlerExample(middlewares, 0, handler))
		}
	}
}

func getChainClientMiddlewareHandlerExample(
	middlewares []func(ctx context.Context, req interface{}, handler func(ctx context.Context, req interface{}) (resp interface{}, err error)) (resp interface{}, err error),
	curr int,
	finalHandler func(ctx context.Context, req interface{}) (resp interface{}, err error),
) func(ctx context.Context, req interface{}) (resp interface{}, err error) {
	if curr == len(middlewares)-1 {
		return finalHandler
	}
	return func(ctx context.Context, req interface{}) (resp interface{}, err error) {
		return middlewares[curr+1](ctx, req, getChainClientMiddlewareHandlerExample(middlewares, curr+1, finalHandler))
	}
}
