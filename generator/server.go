package generator

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GenerateServers generates HTTP servers for all services in the file
func (g *generator) GenerateServers(file *protogen.File) (err error) {
	g.gf.P("// Code generated by protoc-gen-httpgo. DO NOT EDIT.")
	g.gf.P("// source: ", file.Desc.Path())
	g.gf.P()
	g.gf.P("package ", file.GoPackageName)

	for _, service := range g.services {
		g.genServiceInterface(service)
		if *g.cfg.Only == onlyClient {
			continue
		}
		if err = g.genServiceServer(service); err != nil {
			return err
		}
	}
	if *g.cfg.Only == onlyClient {
		return nil
	}

	g.genChainServerMiddlewares()
	return nil
}

// genServiceInterface generates interface for HTTP server and client
func (g *generator) genServiceInterface(service serviceParams) {
	g.gf.P("type ", service.name, "HTTPGoService interface {")
	for _, method := range service.methods {
		g.gf.P(
			"	", method.name, "(", contextPackage.Ident("Context"), ", *", method.inputMsgName, ") ",
			"(*", method.outputMsgName, ", error)",
		)
	}
	g.gf.P("}")
}

// genServiceServer generates HTTP server for serviceParams
func (g *generator) genServiceServer(service serviceParams) (err error) {
	g.gf.P("func Register", service.name, "HTTPGoServer(")
	g.gf.P("	_ ", contextPackage.Ident("Context"), ",")
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	r *", g.lib.Ident("ServeMux"), ",")
	case libraryFastHTTP:
		g.gf.P("	r *", routerPackage.Ident("Router"), ",")
	}
	g.gf.P("	h ", service.name, "HTTPGoService,")
	g.gf.P("	middlewares []func(", g.serverInput, ", handler func(", g.serverInput, ") (", g.serverOutput, ")) (", g.serverOutput, "),")
	g.gf.P(") error {")
	g.gf.P("	var middleware = chainServerMiddlewares", g.filename, "(middlewares)")
	for _, method := range service.methods {
		g.genMethodDeclaration(service.name, method)
	}
	g.gf.P("	return nil")
	g.gf.P("}")
	g.gf.P()

	for _, method := range service.methods {
		if err = g.genBuildRequestMethod(service.name, method); err != nil {
			return err
		}
	}
	g.gf.P()
	return nil
}

// genMethodDeclaration generates binding route with handler
func (g *generator) genMethodDeclaration(serviceName string, method methodParams) {
	g.gf.P(method.comment)
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	r.HandleFunc( \"", method.httpMethodName, " ", method.uri, "\", func(w ", g.lib.Ident("ResponseWriter"), ", r *", g.lib.Ident("Request"), ") { ")
		g.gf.P("		input, err := build", g.getBuildMethodInputName(serviceName, method), "(r)")
		g.gf.P("		if err != nil {")
		g.gf.P("			w.WriteHeader(", g.lib.Ident("StatusBadRequest"), ")")
		g.gf.P("			_, _ = w.Write([]byte(err.Error()))")
		g.gf.P("			return")
		g.gf.P("		}")
		g.gf.P("		ctx := r.Context()")
		g.gf.P("		ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"proto_service\", \""+serviceName+"\")")
		g.gf.P("		ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"proto_method\", \""+method.name+"\")")
		g.gf.P("		ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"writer\", w)")
		g.gf.P("		ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"request\", r)")
	case libraryFastHTTP:
		g.gf.P("	r.", method.httpMethodName, "( \"", method.uri, "\", func(ctx *", fasthttpPackage.Ident("RequestCtx"), ") { ")
		g.gf.P("		input, err := build", g.getBuildMethodInputName(serviceName, method), "(ctx)")
		g.gf.P("		if err != nil {")
		g.gf.P("			ctx.SetStatusCode(", fasthttpPackage.Ident("StatusBadRequest"), ")")
		g.gf.P("			_, _ = ctx.WriteString(err.Error())")
		g.gf.P("			return")
		g.gf.P("		}")
		g.gf.P("		ctx.SetUserValue(\"proto_service\", \"" + serviceName + "\")")
		g.gf.P("		ctx.SetUserValue(\"proto_method\", \"" + method.name + "\")")
	}
	g.gf.P("		handler := func(", g.serverInput, ") (", g.serverOutput, ") {")
	g.gf.P("			return h.", method.name, "(ctx, input)")
	g.gf.P("		}")
	g.gf.P("		if middleware == nil {")
	g.gf.P("			_, _ = handler(ctx, input)")
	g.gf.P("			return")
	g.gf.P("		}")
	g.gf.P("		_, _ = middleware(ctx, input, handler)")
	g.gf.P("	})")
	g.gf.P()
}

// getBuildMethodInputName creates name for function that builds method request
func (g *generator) getBuildMethodInputName(serviceName string, method methodParams) string {
	methodName := g.filename + serviceName + method.name + method.inputMsgName.GoName
	return strings.NewReplacer(".", "", "-", "", "_", "").Replace(methodName)
}

// genBuildRequestMethod generates method that build request struct
func (g *generator) genBuildRequestMethod(serviceName string, method methodParams) error {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("func build", g.getBuildMethodInputName(serviceName, method), "(r *", g.lib.Ident("Request"), ") (arg *", method.inputMsgName, ", err error) {")
	case libraryFastHTTP:
		g.gf.P("func build", g.getBuildMethodInputName(serviceName, method), "(ctx *", fasthttpPackage.Ident("RequestCtx"), ") (arg *", method.inputMsgName, ", err error) {")
	}
	g.gf.P("	arg = &", method.inputMsgName, "{}")
	if method.HasBody() {
		g.genUnmarshalRequestStruct()
	}
	var err error
	if len(method.inputFieldList) != 0 {
		switch *g.cfg.Library {
		case libraryNetHTTP:
			g.gf.P("for key, values := range r.URL.Query() {")
			g.gf.P("	var value = values[0]")
		case libraryFastHTTP:
			g.gf.P("ctx.QueryArgs().VisitAll(func(keyB, valueB []byte) {")
			g.gf.P("	var key = string(keyB)")
			g.gf.P("	var value = string(valueB)")
		}
		g.gf.P("	switch key {")
		for _, f := range method.inputFieldList {
			if err = g.genQueryArgCheck(method.inputFields[f]); err != nil {
				return err
			}
		}
		g.gf.P("	default:")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"unknown query parameter %s with value %s\", key, value)")
		g.gf.P("		return")
		g.gf.P("	}")
		switch *g.cfg.Library {
		case libraryNetHTTP:
			g.gf.P("}")
		case libraryFastHTTP:
			g.gf.P("})")
		}
	}

	for _, match := range uriParametersRegexp.FindAllStringSubmatch(method.uri, -1) {
		if f, ok := method.inputFields[match[1]]; ok {
			if err = g.genBuildPathArgument(f); err != nil {
				return err
			}
		}
	}

	g.gf.P("	return arg, err")
	g.gf.P("}")
	g.gf.P()
	return nil
}

// genBuildPathArgument generates code for request argument
func (g *generator) genBuildPathArgument(
	f field,
) error {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	", f.goName, "Str := r.PathValue(\"", f.protoName, "\")")
		g.gf.P("	if len(", f.goName, "Str) == 0 {")
	case libraryFastHTTP:
		g.gf.P("	", f.goName, "Str, ok := ctx.UserValue(\"", f.protoName, "\").(string)")
		g.gf.P("	if !ok || len(", f.goName, "Str) == 0 {")
	}
	g.gf.P("		return nil, ", errorsPackage.Ident("New"), "(\"empty value for parameter ", f.protoName, "\")")
	g.gf.P("	}")
	if f.cardinality == protoreflect.Repeated {
		return g.genRepeatedPathArgCheck(f)
	}
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
		g.gf.P("	", f.goName, ", convErr := ", strconvPackage.Ident("ParseInt"), "(", f.goName, "Str, 10, 32)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	}")
		g.gf.P("	arg.", f.goName, " = ", f.getGolangTypeName(), "(", f.goName, ")")
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		g.gf.P("	arg.", f.goName, ", err = ", strconvPackage.Ident("ParseInt"), "(", f.goName, "Str, 10, 64)")
		g.gf.P("	if err != nil {")
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", err)")
		g.gf.P("	}")
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		g.gf.P("	", f.goName, ", convErr := ", strconvPackage.Ident("ParseInt"), "(", f.goName, "Str, 10, 64)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	}")
		g.gf.P("	arg.", f.goName, " = ", f.getGolangTypeName(), "(", f.goName, ")")
	case protoreflect.DoubleKind:
		g.gf.P("	arg.", f.goName, ", err = ", strconvPackage.Ident("ParseFloat"), "(", f.goName, "Str, 64)")
		g.gf.P("	if err != nil {")
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", err)")
		g.gf.P("	}")
	case protoreflect.FloatKind:
		g.gf.P("	", f.goName, ", convErr := ", strconvPackage.Ident("ParseFloat"), "(", f.goName, "Str, 32)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	}")
		g.gf.P("	arg.", f.goName, " = float32(", f.goName, ")")
	case protoreflect.StringKind:
		g.gf.P("	arg.", f.goName, " = ", f.goName, "Str")
	case protoreflect.BytesKind:
		g.gf.P("	arg.", f.goName, " = []byte(", f.goName, "Str)")
	case protoreflect.BoolKind:
		g.gf.P("	switch ", f.goName, "Str {")
		g.gf.P("	case \"true\", \"t\", \"1\":")
		g.gf.P("		arg." + f.goName + " = true")
		g.gf.P("	case \"false\", \"f\", \"0\":")
		g.gf.P("		arg." + f.goName + " = false")
		g.gf.P("	default:")
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"unknown bool string value %s\", ", f.goName, "Str)")
		g.gf.P("	}")
	case protoreflect.EnumKind:
		g.gf.P("	", f.enumName.GoName, "Value, optValueOk := ", f.enumName, "_value[", stringsPackage.Ident("ToUpper"), "(", f.goName, "Str)]")
		g.gf.P("	if optValueOk {")
		g.gf.P("		arg.", f.goName, " = ", f.enumName, "(", f.enumName.GoName, "Value)")
		g.gf.P("	} else {")
		g.gf.P("		if intOptionValue, convErr := ", strconvPackage.Ident("ParseInt"), "(", f.goName, "Str, 10, 32); convErr == nil {")
		g.gf.P("			if _, optIntValueOk := ", f.enumName, "_name[int32(intOptionValue)]; optIntValueOk {")
		g.gf.P("			arg.", f.goName, " = ", f.enumName, "(intOptionValue)")
		g.gf.P("			}")
		g.gf.P("		}")
		g.gf.P("	}")
	default:
		return fmt.Errorf("unsupported type %s for path variable", f.kind.String())
	}
	g.gf.P()
	return nil
}

func (g *generator) genRepeatedPathArgCheck(f field) error {
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseInt"), "(str, 10, 32)")
		g.gf.P("if convErr != nil {")
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("return nil, err")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.getGolangTypeName(), "(", f.goName, "Val))")
		g.gf.P("}")
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseInt"), "(str, 10, 64)")
		g.gf.P("if convErr != nil {")
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("return nil, err")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.goName, "Val)")
		g.gf.P("}")
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseUint"), "(str, 10, 64)")
		g.gf.P("if convErr != nil {")
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("return nil, err")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.goName, "Val)")
		g.gf.P("}")
	case protoreflect.DoubleKind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseFloat"), "(str, 64)")
		g.gf.P("if convErr != nil {")
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	return nil, err")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.goName, "Val)")
		g.gf.P("}")
	case protoreflect.FloatKind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseFloat"), "(str, 32)")
		g.gf.P("if convErr != nil {")
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("return nil, err")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", float32(", f.goName, "Val))")
		g.gf.P("}")
	case protoreflect.StringKind:
		g.gf.P("arg.", f.goName, " = ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
	case protoreflect.BytesKind:
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", []byte(", f.goName, "Str))")
	case protoreflect.BoolKind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P("switch str {")
		g.gf.P("case \"true\", \"t\", \"1\":")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", true)")
		g.gf.P("case \"false\", \"f\", \"0\":")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", false)")
		g.gf.P("default:")
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"unknown bool string value %s\", str)")
		g.gf.P("return nil, err")
		g.gf.P("}")
		g.gf.P("}")
	case protoreflect.EnumKind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		g.gf.P("if ", f.enumName.GoName, "Value, optValueOk := ", f.enumName, "_value[", stringsPackage.Ident("ToUpper"), "(str)]; optValueOk {")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.enumName, "(", f.enumName.GoName, "Value))")
		g.gf.P("} else {")
		g.gf.P("if intOptionValue, convErr := ", strconvPackage.Ident("ParseInt"), "(str, 10, 32); convErr == nil {")
		g.gf.P("if _, optIntValueOk := ", f.enumName, "_name[int32(intOptionValue)]; optIntValueOk {")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.enumName, "(intOptionValue))")
		g.gf.P("}")
		g.gf.P("}")
		g.gf.P("}")
		g.gf.P("}")
	default:
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"unsupported type repeated ", f.kind.String(), " for path argument ", f.goName, "\")")
		g.gf.P("return nil, err")
	}
	return nil
}

// genChainServerMiddlewares generates server middleware chain functions
func (g *generator) genChainServerMiddlewares() {
	g.gf.P("func chainServerMiddlewares", g.filename, "(")
	g.gf.P("	middlewares []func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, "),")
	g.gf.P(") func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, ") {")
	g.gf.P("	switch len(middlewares) {")
	g.gf.P("	case 0:")
	g.gf.P("		return nil")
	g.gf.P("	case 1:")
	g.gf.P("		return middlewares[0]")
	g.gf.P("	default:")
	g.gf.P("		return func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, ") {")
	g.gf.P("			return middlewares[0](ctx, req, getChainServerMiddlewareHandler", g.filename, "(middlewares, 0, handler))")
	g.gf.P("		}")
	g.gf.P("	}")
	g.gf.P("}")
	g.gf.P()
	g.gf.P("func getChainServerMiddlewareHandler", g.filename, "(")
	g.gf.P("	middlewares []func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, "),")
	g.gf.P("	curr int,")
	g.gf.P("	finalHandler func(", g.serverInput, ")(", g.serverOutput, "),")
	g.gf.P(") func(", g.serverInput, ") (", g.serverOutput, ") {")
	g.gf.P("	if curr == len(middlewares)-1 {")
	g.gf.P("		return finalHandler")
	g.gf.P("	}")
	g.gf.P("	return func(", g.serverInput, ") (", g.serverOutput, ") {")
	g.gf.P("		return middlewares[curr+1](ctx, req, getChainServerMiddlewareHandler", g.filename, "(middlewares, curr+1, finalHandler))")
	g.gf.P("	}")
	g.gf.P("}")
}

// genUnmarshalRequestStruct generates unmarshalling from []byte to struct for request
func (g *generator) genUnmarshalRequestStruct() {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	var body []byte")
		g.gf.P("	if body, err = ", ioPackage.Ident("ReadAll"), "(r.Body); err != nil {")
		g.gf.P("		return nil, err")
		g.gf.P("	}")
		g.gf.P("	_ = r.Body.Close()")
	case libraryFastHTTP:
		g.gf.P("	var body = ctx.PostBody()")
	}
	g.gf.P("	if len(body) > 0 { ")
	switch *g.cfg.Marshaller {
	case marshallerEasyJSON:
		g.gf.P("		if argEJ, ok := interface{}(arg).(", easyjsonPackage.Ident("Unmarshaler"), "); ok {")
		g.gf.P("			if err = ", easyjsonPackage.Ident("Unmarshal"), "(body, argEJ); err != nil {")
		g.gf.P("				return nil, err")
		g.gf.P("			}")
		g.gf.P("		} else {")
		g.gf.P("			if err = ", jsonPackage.Ident("Unmarshal"), "(body, arg); err != nil {")
		g.gf.P("				return nil, err")
		g.gf.P("			}")
		g.gf.P("		}")
	case marshallerProtoJSON:
		g.gf.P("		if err = ", protojsonPackage.Ident("Unmarshal"), "(body, arg); err != nil {")
		g.gf.P("			return nil, err")
		g.gf.P("		}")
	default:
		g.gf.P("		if err = ", jsonPackage.Ident("Unmarshal"), "(body, arg); err != nil {")
		g.gf.P("			return nil, err")
		g.gf.P("		}")
	}
	g.gf.P("	}")
}

func (g *generator) genQueryArgCheck(f field) (err error) {
	if f.cardinality == protoreflect.Repeated {
		g.gf.P("	case \"" + f.protoName + "[]\":")
		return g.genRepeatedQueryArgCheck(f)
	}
	var reference = ""
	if f.optional {
		reference = "&"
	}

	g.gf.P("	case \"" + f.protoName + "\":")
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
		g.gf.P("	", f.goName, ", convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 32)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("	", f.goName, "Value := ", f.getGolangTypeName(), "(", f.goName, ")")
		g.gf.P("	arg.", f.goName, " = ", reference, f.goName, "Value")
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		g.gf.P("	", f.goName, "Value, convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 64)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("	arg.", f.goName, " = ", reference, f.goName, "Value")
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		g.gf.P("	", f.goName, ", convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 64)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("	", f.goName, "Value := ", f.getGolangTypeName(), "(", f.goName, ")")
		g.gf.P("	arg.", f.goName, " = ", reference, f.goName, "Value")
	case protoreflect.DoubleKind:
		g.gf.P("	", f.goName, "Value, convErr := ", strconvPackage.Ident("ParseFloat"), "(value, 64)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("	arg.", f.goName, " = ", reference, f.goName, "Value")
	case protoreflect.FloatKind:
		g.gf.P("	", f.goName, ", convErr := ", strconvPackage.Ident("ParseFloat"), "(value, 32)")
		g.gf.P("	if convErr != nil {")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("	", f.goName, "Value := float32(", f.goName, ")")
		g.gf.P("	arg.", f.goName, " = ", reference, f.goName, "Value")
	case protoreflect.StringKind:
		g.gf.P("	arg.", f.goName, " = ", reference, "value")
	case protoreflect.BytesKind:
		g.gf.P("	arg." + f.goName + " = []byte(value)")
	case protoreflect.BoolKind:
		g.gf.P("	switch value {")
		g.gf.P("	case \"true\", \"t\", \"1\":")
		g.gf.P("		" + f.goName + "Value := true")
		g.gf.P("		arg."+f.goName+" = ", reference, f.goName, "Value")
		g.gf.P("	case \"false\", \"f\", \"0\":")
		g.gf.P("		" + f.goName + "Value := false")
		g.gf.P("		arg."+f.goName+" = ", reference, f.goName, "Value")
		g.gf.P("	default:")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"unknown bool string value %s\", value)")
		g.gf.P("		return")
		g.gf.P("	}")
	case protoreflect.EnumKind:
		g.gf.P("	if ", f.enumName.GoName, "Value, optValueOk := ", f.enumName, "_value[", stringsPackage.Ident("ToUpper"), "(value)]; optValueOk {")
		g.gf.P("		", f.goName, f.enumName.GoName, "Value := ", f.enumName, "(", f.enumName.GoName, "Value)")
		g.gf.P("		arg.", f.goName, " = ", reference, f.goName, f.enumName.GoName, "Value")
		g.gf.P("	} else {")
		g.gf.P("		if intOptionValue, convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 32); convErr == nil {")
		g.gf.P("			if _, optIntValueOk := ", f.enumName, "_name[int32(intOptionValue)]; optIntValueOk {")
		g.gf.P("				", f.goName, f.enumName.GoName, "Value := ", f.enumName, "(intOptionValue)")
		g.gf.P("				arg.", f.goName, " = ", reference, f.goName, f.enumName.GoName, "Value")
		g.gf.P("			}")
		g.gf.P("		}")
		g.gf.P("	}")
	default:
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"unsupported type "+f.kind.String()+" for query argument "+f.protoName+"\")")
		g.gf.P("	return")
	}
	return nil
}

func (g *generator) genRepeatedQueryArgCheck(f field) error {
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 32)")
		g.gf.P("if convErr != nil {")
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	return")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.getGolangTypeName(), "(", f.goName, "Val))")
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 64)")
		g.gf.P("if convErr != nil {")
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	return")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.goName, "Val)")
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseUint"), "(value, 10, 64)")
		g.gf.P("if convErr != nil {")
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	return")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.goName, "Val)")
	case protoreflect.DoubleKind:
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseFloat"), "(value, 64)")
		g.gf.P("if convErr != nil {")
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	return")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", ", f.goName, "Val)")
	case protoreflect.FloatKind:
		g.gf.P(f.goName, "Val, convErr := ", strconvPackage.Ident("ParseFloat"), "(value, 32)")
		g.gf.P("if convErr != nil {")
		g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", f.protoName, ": %w\", convErr)")
		g.gf.P("	return")
		g.gf.P("}")
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", float32(", f.goName, "Val))")
	case protoreflect.StringKind:
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", value)")
	case protoreflect.BytesKind:
		g.gf.P("arg.", f.goName, " = append(arg.", f.goName, ", []byte(value))")
	case protoreflect.BoolKind:
		g.gf.P("switch value {")
		g.gf.P("	case \"true\", \"t\", \"1\":")
		g.gf.P("		arg.", f.goName, " = append(arg.", f.goName, ", true)")
		g.gf.P("	case \"false\", \"f\", \"0\":")
		g.gf.P("		arg.", f.goName, " = append(arg.", f.goName, ", false)")
		g.gf.P("	default:")
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"unknown bool string value %s\", value)")
		g.gf.P("		return")
		g.gf.P("}")
	case protoreflect.EnumKind:
		g.gf.P("if ", f.enumName.GoName, "Value, optValueOk := ", f.enumName, "_value[", stringsPackage.Ident("ToUpper"), "(value)]; optValueOk {")
		g.gf.P("	arg.", f.goName, " = append(arg.", f.goName, ", ", f.enumName, "(", f.enumName.GoName, "Value))")
		g.gf.P("} else {")
		g.gf.P("	if intOptionValue, convErr := ", strconvPackage.Ident("ParseInt"), "(value, 10, 32); convErr == nil {")
		g.gf.P("		if _, optIntValueOk := ", f.enumName, "_name[int32(intOptionValue)]; optIntValueOk {")
		g.gf.P("			arg.", f.goName, " = append(arg.", f.goName, ", ", f.enumName, "(intOptionValue))")
		g.gf.P("		}")
		g.gf.P("	}")
		g.gf.P("}")
	default:
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"unsupported type repeated ", f.kind.String(), " for query argument ", f.protoName, "\")")
		g.gf.P("return")
	}
	return nil
}
