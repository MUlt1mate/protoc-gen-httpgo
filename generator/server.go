package generator

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GenerateServers generates HTTP servers for all services if the file
func GenerateServers(gen *protogen.Plugin, file *protogen.File) (err error) {
	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".httpgo.srv.go", file.GoImportPath)
	g.P("// Code generated by protoc-gen-httpgo. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)

	for _, srv := range file.Services {
		genServiceInterface(g, srv)
		if err = genServiceServer(g, srv); err != nil {
			return err
		}
	}

	genResponseHandler(g)
	return nil
}

// genServiceInterface generates interface for HTTP server and client
func genServiceInterface(g *protogen.GeneratedFile, srv *protogen.Service) {
	g.P("type ", srv.GoName, "HTTPService interface {")
	for _, method := range srv.Methods {
		g.P(
			method.GoName, "(", contextPackage.Ident("Context"), ", *", method.Input.GoIdent, ") ",
			"(*", method.Output.GoIdent, ", error)",
		)
	}
	g.P("}")
}

// genServiceServer generates HTTP server for service
func genServiceServer(g *protogen.GeneratedFile, srv *protogen.Service) (err error) {
	g.P("func Register", srv.GoName, "HTTPServer(ctx context.Context, r *", routerPackage.Ident("Router"), ", h ", srv.GoName, "HTTPService) error {")
	for _, method := range srv.Methods {
		if err = genMethodDeclaration(g, method); err != nil {
			return err
		}
	}
	g.P("}")

	for _, method := range srv.Methods {
		if err = genBuildRequestMethod(g, method); err != nil {
			return err
		}
	}
	g.P("")

	return nil
}

// genMethodDeclaration generates binding route with handler
func genMethodDeclaration(g *protogen.GeneratedFile, method *protogen.Method) error {
	var (
		params methodParams
		err    error
	)
	if params, err = getRuleMethodAndURI(method); err != nil {
		return err
	}

	g.P("r.", params.serverMethod, "( \"", params.pattern, "\", func(ctx *", fasthttpPackage.Ident("RequestCtx"), ") { ")
	g.P("	   input, err := build", method.Input.GoIdent, "(ctx)")
	g.P("	   if err != nil {")
	g.P("	   	responseHandler(ctx, nil, err)")
	g.P("	   	return")
	g.P("	   }")
	g.P("    response, err := h.", method.GoName, "(ctx, input)")
	g.P("    responseHandler(ctx, response, err)")
	g.P("})")
	g.P("")
	g.P("return nil")

	return nil
}

// genBuildRequestMethod generates method that build request struct
func genBuildRequestMethod(g *protogen.GeneratedFile, method *protogen.Method) error {
	g.P("func build", method.Input.GoIdent, "(ctx *", fasthttpPackage.Ident("RequestCtx"), ") (arg *", method.Input.GoIdent, ", err error) {")
	g.P("	arg = &", method.Input.GoIdent, "{}")
	g.P("	", jsonPackage.Ident("Unmarshal"), "(ctx.PostBody(), arg)")

	var (
		params methodParams
		err    error
	)
	if params, err = getRuleMethodAndURI(method); err != nil {
		return err
	}
	for _, match := range uriParametersRegexp.FindAllStringSubmatch(params.pattern, -1) {
		for _, f := range method.Input.Fields {
			if f.GoName == capitalizeFirstLetter(match[1]) {
				if err = genBuildRequestArgument(g, match[1], f.Desc.Kind()); err != nil {
					return err
				}
			}
		}
	}

	g.P("	return arg, nil")
	g.P("}")
	return nil
}

// genBuildRequestArgument generates code for request argument
func genBuildRequestArgument(g *protogen.GeneratedFile, parameterName string, parameterKind protoreflect.Kind) error {
	g.P(parameterName, "Str, ok := ctx.UserValue(\"", parameterName, "\").(string)")
	g.P("	if !ok {")
	g.P("		return nil, ", errorsPackage.Ident("New"), "(\"incorrect type for parameter ", parameterName, "\")")
	g.P("	}")
	switch parameterKind {
	case protoreflect.Int64Kind:
		g.P("	arg.", capitalizeFirstLetter(parameterName), ", err = ", strconvPackage.Ident("ParseInt"), "(", parameterName, "Str, 10, 64)")
		g.P("	if err != nil {")
		g.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", parameterName, ": %w\", err)")
		g.P("	}")
		// todo other int types
	case protoreflect.StringKind:
		g.P("	arg.", capitalizeFirstLetter(parameterName), " = ", parameterName, "Str")
	default:
		return fmt.Errorf("unsupported type %s for path variable", parameterKind.String())
	}
	return nil
}

// genResponseHandler generates common handler for any response
func genResponseHandler(g *protogen.GeneratedFile) {
	g.P("func responseHandler(ctx *", fasthttpPackage.Ident("RequestCtx"), ", resp interface{}, respErr error) {")
	g.P("ctx.SetContentType(\"application/json\")")
	g.P("")
	g.P("if respErr == nil {")
	g.P("    ctx.SetStatusCode(", fasthttpPackage.Ident("StatusOK"), ")")
	g.P("} else {")
	g.P("    ", logPackage.Ident("Println"), "(respErr)")
	g.P("    ctx.SetStatusCode(", fasthttpPackage.Ident("StatusInternalServerError"), ")")
	g.P("}")
	g.P("")
	g.P("var data, _ = ", jsonPackage.Ident("Marshal"), "(resp)")
	g.P("_, _ = ctx.Write(data)")
	g.P("}")
}
