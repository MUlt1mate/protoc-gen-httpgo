package generator

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GenerateServers generates HTTP servers for all services in the file
func (g *generator) GenerateServers(file *protogen.File) (err error) {
	g.gf.P("// Code generated by protoc-gen-httpgo. DO NOT EDIT.")
	g.gf.P("// source: ", file.Desc.Path())
	g.gf.P()
	g.gf.P("package ", file.GoPackageName)

	for _, service := range g.services {
		g.genServiceInterface(service)
		if *g.cfg.Only == onlyClient {
			continue
		}
		if err = g.genServiceServer(service); err != nil {
			return err
		}
	}
	if *g.cfg.Only == onlyClient {
		return nil
	}

	g.genChainServerMiddlewares()
	return nil
}

// genServiceInterface generates interface for HTTP server and client
func (g *generator) genServiceInterface(service serviceParams) {
	g.gf.P("type ", service.name, "HTTPGoService interface {")
	for _, method := range service.methods {
		g.gf.P(
			"	", method.name, "(", contextPackage.Ident("Context"), ", *", method.inputMsgName, ") ",
			"(*", method.outputMsgName, ", error)",
		)
	}
	g.gf.P("}")
}

// genServiceServer generates HTTP server for serviceParams
func (g *generator) genServiceServer(service serviceParams) (err error) {
	g.gf.P("func Register", service.name, "HTTPGoServer(")
	g.gf.P("	_ ", contextPackage.Ident("Context"), ",")
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	r *", g.lib.Ident("ServeMux"), ",")
	case libraryFastHTTP:
		g.gf.P("	r *", routerPackage.Ident("Router"), ",")
	case libraryGin:
		g.gf.P("	r *", ginPackage.Ident("Engine"), ",")
	}
	g.gf.P("	h ", service.name, "HTTPGoService,")
	g.gf.P("	middlewares []func(", g.serverInput, ", handler func(", g.serverInput, ") (", g.serverOutput, ")) (", g.serverOutput, "),")
	g.gf.P(") error {")
	g.gf.P("	var middleware = chainServerMiddlewares", g.filename, "(middlewares)")
	for _, method := range service.methods {
		if err = g.genMethodDeclaration(service.name, method); err != nil {
			return err
		}
	}
	g.gf.P("	return nil")
	g.gf.P("}")
	g.gf.P()

	for _, method := range service.methods {
		if err = g.genBuildRequestMethod(service.name, method); err != nil {
			return err
		}
	}
	g.gf.P()
	return nil
}

// genMethodDeclaration generates binding route with handler
func (g *generator) genMethodDeclaration(serviceName string, method methodParams) (err error) {
	g.gf.P(method.comment)
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("r.HandleFunc( \"", method.httpMethodName, " ", method.uri.protoURI, "\", func(w ", g.lib.Ident("ResponseWriter"), ", r *", g.lib.Ident("Request"), ") { ")
		g.gf.P("	w.Header().Set(\"Content-Type\", \"application/json\")")
		g.gf.P("	input, err := build", g.getBuildMethodInputName(serviceName, method), "(r)")
		g.gf.P("	if err != nil {")
		g.gf.P("		w.WriteHeader(", g.lib.Ident("StatusBadRequest"), ")")
		// can't use protojson on inline structure
		g.gf.P("		respJson, _ := ", jsonPackage.Ident("Marshal"), "(struct{ Error string }{Error: err.Error()})")
		g.gf.P("		_, _ = w.Write(respJson)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("	ctx := r.Context()")
		g.gf.P("	ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"writer\", w)")
		g.gf.P("	ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"request\", r)")
	case libraryFastHTTP:
		g.gf.P("r.", method.httpMethodName, "( \"", method.uri.protoURI, "\", func(fastctx *", fasthttpPackage.Ident("RequestCtx"), ") { ")
		g.gf.P("	fastctx.Response.Header.SetContentType(\"application/json\")")
		g.gf.P("	input, err := build", g.getBuildMethodInputName(serviceName, method), "(fastctx)")
		g.gf.P("	if err != nil {")
		g.gf.P("		fastctx.SetStatusCode(", fasthttpPackage.Ident("StatusBadRequest"), ")")
		// can't use protojson on inline structure
		g.gf.P("		respJson, _ := ", jsonPackage.Ident("Marshal"), "(struct{ Error string }{Error: err.Error()})")
		g.gf.P("		_, _ = fastctx.Write(respJson)")
		g.gf.P("		return")
		g.gf.P("	}")
		// wrap fasthttp.RequestCtx further usage
		// Call of ctx.Value will eventually call *fasthttp.RequestCtx.Value
		g.gf.P("	ctx := context.WithValue(fastctx, \"request\", fastctx)")
	case libraryGin:
		g.gf.P("r.", method.httpMethodName, "( \"", method.uri.protoURI, "\", func(ginctx *", ginPackage.Ident("Context"), ") { ")
		g.gf.P("	ginctx.Header(\"Content-Type\", \"application/json\")")
		g.gf.P("	input, err := build", g.getBuildMethodInputName(serviceName, method), "(ginctx)")
		g.gf.P("	if err != nil {")
		g.gf.P("		ginctx.JSON(400, struct{ Error string }{Error: err.Error()})")
		g.gf.P("		return")
		g.gf.P("	}")
		// wrap gin.Context further usage
		g.gf.P("	ctx := context.WithValue(ginctx, \"request\", ginctx)")
	}
	g.gf.P("	ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"proto_service\", \""+serviceName+"\")")
	g.gf.P("	ctx = ", contextPackage.Ident("WithValue"), "(ctx, \"proto_method\", \""+method.name+"\")")
	g.gf.P("	handler := func(", g.serverInput, ") (", g.serverOutput, ") {")
	g.gf.P("		return h.", method.name, "(ctx, input)")
	g.gf.P("	}")
	g.gf.P("	var resp any")
	g.gf.P("	if middleware == nil {")
	// errors should be dealt with in handler or middlewares
	g.gf.P("		resp, _ = handler(ctx, input)")
	g.gf.P("	} else {")
	g.gf.P("		resp, _ = middleware(ctx, input, handler)")
	g.gf.P("	}")
	if method.rule != nil && method.rule.ResponseBody != "" {
		respField, ok := method.outputFields[method.rule.ResponseBody]
		if !ok {
			return fmt.Errorf("field %s not found in struct %s for method %s", method.rule.ResponseBody, method.outputMsgName.String(), method.name)
		}
		g.gf.P("if typedResp, ok := resp.(*", method.inputMsgName, "); ok {")
		g.genMarshalServerResponse("typedResp." + respField.goName)
		g.gf.P("} else {")
		g.genMarshalServerResponse("resp")
		g.gf.P("}")
	} else {
		g.genMarshalServerResponse("resp")
	}
	g.gf.P("})")
	g.gf.P()
	if method.rule != nil && len(method.rule.AdditionalBindings) > 0 {
		// this will duplicate whole method. can be optimized
		for _, binding := range method.rule.AdditionalBindings {
			copiedMethod := method.Copy()
			copiedMethod.httpMethodName, copiedMethod.uri.protoURI = getRuleMethodAndURI(binding)
			copiedMethod.uri.parseURI(*g.cfg.Library)
			copiedMethod.rule.AdditionalBindings = nil
			if err = g.genMethodDeclaration(serviceName, copiedMethod); err != nil {
				return err
			}
		}
	}
	return nil
}

func (g *generator) genMarshalServerResponse(source string) {
	if *g.cfg.Library == libraryGin && *g.cfg.Marshaller != marshallerProtoJSON {
		g.gf.P("	ginctx.JSON(ginctx.Writer.Status(), ", source, ")")
		return
	}

	// we can't assert interface if source is a field
	if *g.cfg.Marshaller == marshallerProtoJSON && source == "resp" {
		g.gf.P("	respJson, _ := ", g.marshaller.Ident("Marshal"), "(", source, ".(", protoPackage.Ident("Message"), "))")
	} else {
		g.gf.P("	respJson, _ := ", g.marshaller.Ident("Marshal"), "(", source, ")")
	}

	switch *g.cfg.Library {
	case libraryFastHTTP:
		g.gf.P("	_, _ = fastctx.Write(respJson)")
	case libraryNetHTTP:
		g.gf.P("	_, _ = w.Write(respJson)")
	case libraryGin:
		g.gf.P("	ginctx.Data(ginctx.Writer.Status(), \"application/json\", respJson)")
	}
}

// getBuildMethodInputName creates name for function that builds method request
func (g *generator) getBuildMethodInputName(serviceName string, method methodParams) string {
	methodName := g.filename + serviceName + method.name + method.inputMsgName.GoName
	return strings.NewReplacer(".", "", "-", "", "_", "").Replace(methodName)
}

// genBuildRequestMethod generates method that build request struct
func (g *generator) genBuildRequestMethod(serviceName string, method methodParams) (err error) {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("func build", g.getBuildMethodInputName(serviceName, method), "(r *", g.lib.Ident("Request"), ") (arg *", method.inputMsgName, ", err error) {")
	case libraryFastHTTP:
		g.gf.P("func build", g.getBuildMethodInputName(serviceName, method), "(ctx *", fasthttpPackage.Ident("RequestCtx"), ") (arg *", method.inputMsgName, ", err error) {")
	case libraryGin:
		g.gf.P("func build", g.getBuildMethodInputName(serviceName, method), "(ctx *", ginPackage.Ident("Context"), ") (arg *", method.inputMsgName, ", err error) {")
	}
	g.gf.P("	arg = &", method.inputMsgName, "{}")
	if method.withFiles {
		if err = g.genMultipartRequestServer(method); err != nil {
			return err
		}
	} else if method.HasBody() {
		if err = g.genUnmarshalRequestStruct(method); err != nil {
			return err
		}
	}
	if err = g.genServerMethodQueryParams(method); err != nil {
		return err
	}

	var allGeneratedFields = make(map[string]struct{})
	if err = g.genMethodPathArguments(method, allGeneratedFields); err != nil {
		return err
	}
	if method.rule != nil && len(method.rule.AdditionalBindings) > 0 {
		for _, binding := range method.rule.AdditionalBindings {
			copiedMethod := method.Copy()
			copiedMethod.httpMethodName, copiedMethod.uri.protoURI = getRuleMethodAndURI(binding)
			copiedMethod.uri.parseURI(*g.cfg.Library)
			if err = g.genMethodPathArguments(copiedMethod, allGeneratedFields); err != nil {
				return err
			}
		}
	}

	g.gf.P("	return arg, err")
	g.gf.P("}")
	g.gf.P()
	return nil
}

func (g *generator) genMethodPathArguments(method methodParams, generatedFields map[string]struct{}) (err error) {
	for _, fieldName := range method.uri.argList {
		if _, ok := generatedFields[fieldName]; ok {
			continue
		}
		if f, ok := method.inputFields[fieldName]; ok {
			if err = g.genBuildPathArgument(f, method.uri.args[fieldName]); err != nil {
				return err
			}
			generatedFields[fieldName] = struct{}{}
		} else {
			return fmt.Errorf("path argument %s found in uri, but not found in method %s argument fields", fieldName, method.name)
		}
	}
	return nil
}

func (g *generator) genServerMethodQueryParams(method methodParams) (err error) {
	if len(method.inputFieldList) == 0 {
		return nil
	}
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("for key, values := range r.URL.Query() {")
		g.gf.P("	for _, value := range values {")
	case libraryFastHTTP:
		g.gf.P("ctx.QueryArgs().VisitAll(func(keyB, valueB []byte) {")
		g.gf.P("	var key = string(keyB)")
		g.gf.P("	var value = string(valueB)")
	case libraryGin:
		g.gf.P("for key, values := range  ctx.Request.URL.Query() {")
		g.gf.P("	for _, value := range values {")
	}
	g.gf.P("	switch key {")
	for _, f := range method.inputFieldList {
		if err = g.genQueryArgCheck(method.inputFields[f]); err != nil {
			return err
		}
	}
	g.gf.P("	default:")

	switch *g.cfg.Library {
	case libraryNetHTTP, libraryGin:
		g.gf.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"unknown query parameter %s with value %s\", key, value)")
		g.gf.P("	}")
		g.gf.P("}")
		g.gf.P("}")
	case libraryFastHTTP:
		g.gf.P("		err = ", fmtPackage.Ident("Errorf"), "(\"unknown query parameter %s with value %s\", key, value)")
		g.gf.P("		return")
		g.gf.P("	}")
		g.gf.P("})")
	}
	return nil
}

// genBuildPathArgument generates code for request argument
func (g *generator) genBuildPathArgument(
	f field,
	uriArg methodURIArg,
) (err error) {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	", f.goName, "Str := r.PathValue(\"", f.protoName, "\")")
		g.gf.P("	if len(", f.goName, "Str) != 0 {")
	case libraryFastHTTP:
		g.gf.P("	", f.goName, "Str, ok := ctx.UserValue(\"", f.protoName, "\").(string)")
		g.gf.P("	if ok && len(", f.goName, "Str) != 0 {")
	case libraryGin:
		g.gf.P("	", f.goName, "Str := ctx.Param(\"", f.protoName, "\")")
		g.gf.P("	if len(", f.goName, "Str) != 0 {")
	}
	if f.cardinality == protoreflect.Repeated {
		if err = g.genRepeatedPathArgCheck(f); err != nil {
			return err
		}
		g.gf.P("	}")
		g.gf.P()
		return nil
	}
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind,
		protoreflect.DoubleKind, protoreflect.FloatKind, protoreflect.StringKind, protoreflect.BytesKind, protoreflect.BoolKind,
		protoreflect.EnumKind:
		if err = g.genFieldConvertor(f, f.goName+"Str", "arg."+f.goName, false, "nil, ", false); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported type %s for path variable", f.kind.String())
	}
	if *g.cfg.Library == libraryFastHTTP {
		switch f.kind {
		case protoreflect.StringKind:
			g.gf.P("if arg.", f.goName, ", err = ", urlPackage.Ident("PathUnescape"), "(arg.", f.goName, "); err != nil {")
			g.gf.P("	return nil, fmt.Errorf(\"PathUnescape failed for field ", f.protoName, ": %w\", err)")
			g.gf.P("}")
		case protoreflect.BytesKind:
			g.gf.P("if ", f.goName, "Str, err = ", urlPackage.Ident("PathUnescape"), "(string(arg.", f.goName, ")); err != nil {")
			g.gf.P("	return nil, fmt.Errorf(\"PathUnescape failed for field ", f.protoName, ": %w\", err)")
			g.gf.P("}")
			g.gf.P("arg.", f.goName, " = []byte(", f.goName, "Str)")
		}
	}
	if uriArg.DestinationTpl != "" {
		g.gf.P("arg.", f.goName, " = ", fmtPackage.Ident("Sprintf"), "(\"", uriArg.DestinationTpl, "\", arg.", f.goName, ")")
	}
	g.gf.P("	}")
	g.gf.P()
	return nil
}

func (g *generator) genRepeatedPathArgCheck(f field) (err error) {
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind,
		protoreflect.DoubleKind, protoreflect.FloatKind, protoreflect.BoolKind, protoreflect.EnumKind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		// allocate space and override values if it was passed in a body or other way
		g.gf.P("arg.", f.goName, " = make([]", getFieldConversionFuncName(f), ", 0, len(", f.goName, "Strs))")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		if err = g.genFieldConvertor(f, "str", "arg."+f.goName, true, "nil, ", false); err != nil {
			return err
		}
		g.gf.P("}")
	case protoreflect.StringKind:
		source := g.gf.QualifiedGoIdent(stringsPackage.Ident("Split")) + "(" + f.goName + "Str, \"" + pathRepeatedArgDelimiter + "\")"
		if err = g.genFieldConvertor(f, source, "arg."+f.goName, false, "", false); err != nil {
			return err
		}
	case protoreflect.BytesKind:
		g.gf.P(f.goName, "Strs := ", stringsPackage.Ident("Split"), "(", f.goName, "Str, \""+pathRepeatedArgDelimiter+"\")")
		// allocate space and override values if it was passed in a body or other way
		g.gf.P("arg.", f.goName, " = make([][]byte, 0, len(", f.goName, "Strs))")
		g.gf.P("for _, str := range ", f.goName, "Strs {")
		if err = g.genFieldConvertor(f, "str", "arg."+f.goName, true, "", false); err != nil {
			return err
		}
		g.gf.P("}")
	default:
		g.gf.P("err = ", fmtPackage.Ident("Errorf"), "(\"unsupported type repeated ", f.kind.String(), " for path argument ", f.goName, "\")")
		g.gf.P("return nil, err")
	}
	if *g.cfg.Library == libraryFastHTTP {
		switch f.kind {
		case protoreflect.StringKind:
			g.gf.P("for i, value := range arg.", f.goName, " {")
			g.gf.P("	if arg.", f.goName, "[i], err = ", urlPackage.Ident("PathUnescape"), "(value); err != nil {")
			g.gf.P("		return nil, fmt.Errorf(\"PathUnescape failed for field ", f.protoName, ": %w\", err)")
			g.gf.P("	}")
			g.gf.P("}")
		case protoreflect.BytesKind:
			g.gf.P("for i, value := range arg.", f.goName, " {")
			g.gf.P("	if ", f.goName, "Str, err = ", urlPackage.Ident("PathUnescape"), "(string(value)); err != nil {")
			g.gf.P("		return nil, fmt.Errorf(\"PathUnescape failed for field ", f.protoName, ": %w\", err)")
			g.gf.P("	}")
			g.gf.P("	arg.", f.goName, "[i] = []byte(", f.goName, "Str)")
			g.gf.P("}")
		}
	}
	return nil
}

// genChainServerMiddlewares generates server middleware chain functions
func (g *generator) genChainServerMiddlewares() {
	g.gf.P("func chainServerMiddlewares", g.filename, "(")
	g.gf.P("	middlewares []func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, "),")
	g.gf.P(") func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, ") {")
	g.gf.P("	switch len(middlewares) {")
	g.gf.P("	case 0:")
	g.gf.P("		return nil")
	g.gf.P("	case 1:")
	g.gf.P("		return middlewares[0]")
	g.gf.P("	default:")
	g.gf.P("		return func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, ") {")
	g.gf.P("			return middlewares[0](ctx, req, getChainServerMiddlewareHandler", g.filename, "(middlewares, 0, handler))")
	g.gf.P("		}")
	g.gf.P("	}")
	g.gf.P("}")
	g.gf.P()
	g.gf.P("func getChainServerMiddlewareHandler", g.filename, "(")
	g.gf.P("	middlewares []func(", g.serverInput, ", handler func(", g.serverInput, ")(", g.serverOutput, ")) (", g.serverOutput, "),")
	g.gf.P("	curr int,")
	g.gf.P("	finalHandler func(", g.serverInput, ")(", g.serverOutput, "),")
	g.gf.P(") func(", g.serverInput, ") (", g.serverOutput, ") {")
	g.gf.P("	if curr == len(middlewares)-1 {")
	g.gf.P("		return finalHandler")
	g.gf.P("	}")
	g.gf.P("	return func(", g.serverInput, ") (", g.serverOutput, ") {")
	g.gf.P("		return middlewares[curr+1](ctx, req, getChainServerMiddlewareHandler", g.filename, "(middlewares, curr+1, finalHandler))")
	g.gf.P("	}")
	g.gf.P("}")
}

// genUnmarshalRequestStruct generates unmarshalling from []byte to struct for request
func (g *generator) genUnmarshalRequestStruct(method methodParams) (err error) {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("	var body []byte")
		g.gf.P("	if body, err = ", ioPackage.Ident("ReadAll"), "(r.Body); err != nil {")
		g.gf.P("		return nil, err")
		g.gf.P("	}")
		g.gf.P("	_ = r.Body.Close()")
		g.gf.P("	if len(body) > 0 { ")
	case libraryFastHTTP:
		g.gf.P("	var body = ctx.PostBody()")
		g.gf.P("	if len(body) > 0 { ")
	}
	destination := "arg"
	if method.rule != nil && method.rule.Body != "" && method.rule.Body != "*" {
		f, ok := method.inputFields[method.rule.Body]
		if !ok {
			return fmt.Errorf("field %s set as body value, but not found in method %s argument fields", method.rule.Body, method.name)
		}
		destination = "arg." + f.goName
		g.gf.P("	", destination, " = &", f.structTypeIdent, "{}")
	}
	if *g.cfg.Library == libraryGin {
		g.gf.P("	if err = ctx.ShouldBindBodyWithJSON(", destination, "); err != nil {")
		g.gf.P("		return nil, err")
		g.gf.P("	}")
		return nil
	}
	g.gf.P("		if err = ", g.marshaller.Ident("Unmarshal"), "(body, ", destination, "); err != nil {")
	g.gf.P("			return nil, err")
	g.gf.P("		}")
	g.gf.P("	}")
	return nil
}

func (g *generator) genMultipartRequestServer(method methodParams) (err error) {
	switch *g.cfg.Library {
	case libraryFastHTTP, libraryGin:
		g.gf.P("form, err := ctx.MultipartForm()")
		g.gf.P("if err != nil {")
		g.gf.P("	return nil, err")
		g.gf.P("}")
	case libraryNetHTTP:
		g.gf.P("if err = r.ParseMultipartForm(32 << 20); err != nil {")
		g.gf.P("	return nil, err")
		g.gf.P("}")
	}
	for _, fieldName := range method.inputFieldList {
		f := method.inputFields[fieldName]
		if f.isFile {
			g.genMultipartServerRequestField(f)
			continue
		}
		switch *g.cfg.Library {
		case libraryFastHTTP:
			g.gf.P("if values, ok := form.Value[\"", f.protoName, "\"]; ok && len(values) > 0 {")
		case libraryNetHTTP:
			g.gf.P("if values := r.Form[\"", f.protoName, "\"]; len(values) > 0 {")
		case libraryGin:
			g.gf.P("if values := form.Value[\"", f.protoName, "\"]; len(values) > 0 {")
		}
		switch {
		case f.cardinality == protoreflect.Repeated && f.kind == protoreflect.StringKind:
			g.gf.P("	arg."+f.goName, " = append(arg."+f.goName, ", values...)")
		case f.cardinality == protoreflect.Repeated:
			g.gf.P("	for _, value := range values {")
			if err = g.genFieldConvertor(f, "value", "arg."+f.goName, true, "nil, ", false); err != nil {
				return err
			}
			g.gf.P("	}")
		default:
			if err = g.genFieldConvertor(f, "values[0]", "arg."+f.goName, false, "nil, ", false); err != nil {
				return err
			}
		}
		g.gf.P("}")
	}
	return nil
}

func (g *generator) genMultipartServerRequestField(methodField field) {
	switch *g.cfg.Library {
	case libraryNetHTTP:
		g.gf.P("f, fh, err := r.FormFile(\"", methodField.protoName, "\")")
		g.gf.P("if err == nil && !", errorsPackage.Ident("Is"), "(err, ", httpPackage.Ident("ErrMissingFile"), ") {")
		g.gf.P("	arg.", methodField.goName, " = &", methodField.fileStructIdent(), "{")
		g.gf.P("		File:    make([]byte, fh.Size),")
		g.gf.P("		Name:    fh.Filename,")
		g.gf.P("		Headers: make(map[string]string, len(fh.Header)),")
		g.gf.P("	}")
		g.gf.P("	for key, value := range fh.Header {")
	case libraryFastHTTP:
		g.gf.P("if file, ok := form.File[\"", methodField.protoName, "\"]; ok && len(file) > 0 {")
		g.gf.P("	var f ", multipartPackage.Ident("File"))
		g.gf.P("	f, err = file[0].Open()")
		g.gf.P("	if err != nil {")
		g.gf.P("		return nil, fmt.Errorf(\"failed to open file: ", methodField.protoName, ": %w\", err)")
		g.gf.P("	}")
		g.gf.P("	arg.", methodField.goName, " = &", methodField.fileStructIdent(), "{")
		g.gf.P("		File:    make([]byte, file[0].Size),")
		g.gf.P("		Name:    file[0].Filename,")
		g.gf.P("		Headers: make(map[string]string, len(file[0].Header)),")
		g.gf.P("	}")
		g.gf.P("	for key, value := range file[0].Header {")
	case libraryGin:
		g.gf.P("if file, ok := form.File[\"", methodField.protoName, "\"]; ok && len(file) > 0 {")
		g.gf.P("	var f ", multipartPackage.Ident("File"))
		g.gf.P("	f, err = file[0].Open()")
		g.gf.P("	if err != nil {")
		g.gf.P("		return nil, fmt.Errorf(\"failed to open file: ", methodField.protoName, ": %w\", err)")
		g.gf.P("	}")
		g.gf.P("	arg.", methodField.goName, " = &", methodField.fileStructIdent(), "{")
		g.gf.P("		File:    make([]byte, file[0].Size),")
		g.gf.P("		Name:    file[0].Filename,")
		g.gf.P("		Headers: make(map[string]string, len(file[0].Header)),")
		g.gf.P("	}")
		g.gf.P("	for key, value := range file[0].Header {")
	}
	g.gf.P("		arg.", methodField.goName, ".Headers[key] = value[0]")
	g.gf.P("	}")
	g.gf.P("	_, err = f.Read(arg.", methodField.goName, ".File)")
	g.gf.P("	if err != nil {")
	g.gf.P("		return nil, fmt.Errorf(\"failed to read file: ", methodField.protoName, ": %w\", err)")
	g.gf.P("	}")
	g.gf.P("}")
}

func (g *generator) genQueryArgCheck(f field) (err error) {
	if f.cardinality == protoreflect.Repeated {
		g.gf.P("	case \"", f.protoName, "[]\":")
	} else {
		g.gf.P("	case \"", f.protoName, "\":")
	}

	nakedReturn := *g.cfg.Library == libraryFastHTTP
	switch f.kind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind,
		protoreflect.DoubleKind, protoreflect.FloatKind, protoreflect.StringKind, protoreflect.BytesKind, protoreflect.BoolKind,
		protoreflect.EnumKind:
		if err = g.genFieldConvertor(
			f,
			"value",
			"arg."+f.goName,
			f.cardinality == protoreflect.Repeated,
			"nil, ",
			nakedReturn,
		); err != nil {
			return err
		}
	default:
		if *g.cfg.Library == libraryFastHTTP {
			g.gf.P("	err = ", fmtPackage.Ident("Errorf"), "(\"unsupported type "+f.kind.String()+" for query argument "+f.protoName+"\")")
			g.gf.P("	return")
		} else {
			g.gf.P("	return nil, ", fmtPackage.Ident("Errorf"), "(\"unsupported type "+f.kind.String()+" for query argument "+f.protoName+"\")")
		}
	}

	if f.kind == protoreflect.MessageKind && !f.isFile && f.cardinality != protoreflect.Repeated {
		for _, sf := range f.structFields {
			if sf.Desc.Cardinality() == protoreflect.Repeated ||
				sf.Desc.HasOptionalKeyword() || // todo add optional sub fields
				sf.Desc.Kind() == protoreflect.MessageKind { // for now support first sublevel fields only
				continue
			}
			g.gf.P("	case \"", f.protoName, ".", sf.Desc.TextName(), "\":")
			g.gf.P("		if arg.", f.goName, " == nil {")
			g.gf.P("			arg.", f.goName, " = &", f.structTypeIdent, "{}")
			g.gf.P("		}")
			if err = g.genFieldConvertor(
				convertField(sf),
				"value",
				"arg."+f.goName+"."+sf.GoName,
				f.cardinality == protoreflect.Repeated,
				"nil, ",
				nakedReturn,
			); err != nil {
				return err
			}
		}
	}
	return nil
}
