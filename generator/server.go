package generator

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GenerateServers generates HTTP servers for all services if the file
func GenerateServers(gen *protogen.Plugin, file *protogen.File) (err error) {
	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".httpgo.srv.go", file.GoImportPath)
	g.P("// Code generated by protoc-gen-httpgo. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)

	for _, srv := range file.Services {
		genServiceInterface(g, srv)
		if err = genServiceServer(g, srv); err != nil {
			return err
		}
	}

	genResponseHandler(g)
	return nil
}

// genServiceInterface generates interface for HTTP server and client
func genServiceInterface(g *protogen.GeneratedFile, srv *protogen.Service) {
	g.P("type ", srv.GoName, "HTTPService interface {")
	for _, method := range srv.Methods {
		g.P(
			method.GoName, "(", contextPackage.Ident("Context"), ", *", method.Input.GoIdent, ") ",
			"(*", method.Output.GoIdent, ", error)",
		)
	}
	g.P("}")
}

// genServiceServer generates HTTP server for service
func genServiceServer(g *protogen.GeneratedFile, srv *protogen.Service) (err error) {
	g.P("func Register", srv.GoName, "HTTPServer(ctx context.Context, r *", routerPackage.Ident("Router"), ", h ", srv.GoName, "HTTPService) error {")
	for _, method := range srv.Methods {
		if err = genMethodDeclaration(g, method); err != nil {
			return err
		}
	}
	g.P("}")

	for _, method := range srv.Methods {
		if err = genBuildRequestMethod(g, method); err != nil {
			return err
		}
	}
	g.P("")

	return nil
}

// genMethodDeclaration generates binding route with handler
func genMethodDeclaration(g *protogen.GeneratedFile, method *protogen.Method) error {
	var (
		params methodParams
		err    error
	)
	if params, err = getRuleMethodAndURI(method); err != nil {
		return err
	}

	g.P("r.", params.serverMethod, "( \"", params.pattern, "\", func(ctx *", fasthttpPackage.Ident("RequestCtx"), ") { ")
	g.P("	   input, err := build", method.Input.GoIdent, "(ctx)")
	g.P("	   if err != nil {")
	g.P("	   	responseHandler(ctx, nil, err)")
	g.P("	   	return")
	g.P("	   }")
	g.P("    response, err := h.", method.GoName, "(ctx, input)")
	g.P("    responseHandler(ctx, response, err)")
	g.P("})")
	g.P("")
	g.P("return nil")

	return nil
}

// genBuildRequestMethod generates method that build request struct
func genBuildRequestMethod(g *protogen.GeneratedFile, method *protogen.Method) error {
	g.P("func build", method.Input.GoIdent, "(ctx *", fasthttpPackage.Ident("RequestCtx"), ") (arg *", method.Input.GoIdent, ", err error) {")
	g.P("	arg = &", method.Input.GoIdent, "{}")
	g.P("	", jsonPackage.Ident("Unmarshal"), "(ctx.PostBody(), arg)")

	var (
		params methodParams
		err    error
	)
	if params, err = getRuleMethodAndURI(method); err != nil {
		return err
	}
	for _, match := range uriParametersRegexp.FindAllStringSubmatch(params.pattern, -1) {
		for _, f := range method.Input.Fields {
			if f.GoName == capitalizeFirstLetter(match[1]) {
				var enumName string
				if f.Desc.Kind() == protoreflect.EnumKind {
					enumName = f.Enum.GoIdent.GoName
				}
				if err = genBuildRequestArgument(g, match[1], f.Desc.Kind(), enumName); err != nil {
					return err
				}
			}
		}
	}

	g.P("	return arg, nil")
	g.P("}")
	return nil
}

// genBuildRequestArgument generates code for request argument
func genBuildRequestArgument(
	g *protogen.GeneratedFile,
	parameterName string,
	parameterKind protoreflect.Kind,
	parameterEnumName string,
) error {
	g.P(parameterName, "Str, ok := ctx.UserValue(\"", parameterName, "\").(string)")
	g.P("	if !ok {")
	g.P("		return nil, ", errorsPackage.Ident("New"), "(\"incorrect type for parameter ", parameterName, "\")")
	g.P("	}")
	switch parameterKind {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind, protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind:
		g.P("	", capitalizeFirstLetter(parameterName), ", err := ", strconvPackage.Ident("ParseInt"), "(", parameterName, "Str, 10, 32)")
		g.P("	if err != nil {")
		g.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", parameterName, ": %w\", err)")
		g.P("	}")
		g.P("	arg.", capitalizeFirstLetter(parameterName), " = ", getGolangTypeName(parameterKind), "(", capitalizeFirstLetter(parameterName), ")")
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		g.P("	arg.", capitalizeFirstLetter(parameterName), ", err = ", strconvPackage.Ident("ParseInt"), "(", parameterName, "Str, 10, 64)")
		g.P("	if err != nil {")
		g.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", parameterName, ": %w\", err)")
		g.P("	}")
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		g.P("	", capitalizeFirstLetter(parameterName), ", err := ", strconvPackage.Ident("ParseInt"), "(", parameterName, "Str, 10, 64)")
		g.P("	if err != nil {")
		g.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", parameterName, ": %w\", err)")
		g.P("	}")
		g.P("	arg.", capitalizeFirstLetter(parameterName), " = ", getGolangTypeName(parameterKind), "(", capitalizeFirstLetter(parameterName), ")")
	case protoreflect.DoubleKind:
		g.P("	arg.", capitalizeFirstLetter(parameterName), ", err = ", strconvPackage.Ident("ParseFloat"), "(", parameterName, "Str, 64)")
		g.P("	if err != nil {")
		g.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", parameterName, ": %w\", err)")
		g.P("	}")
	case protoreflect.FloatKind:
		g.P("	", capitalizeFirstLetter(parameterName), ", err := ", strconvPackage.Ident("ParseFloat"), "(", parameterName, "Str, 32)")
		g.P("	if err != nil {")
		g.P("		return nil, ", fmtPackage.Ident("Errorf"), "(\"conversion failed for parameter ", parameterName, ": %w\", err)")
		g.P("	}")
		g.P("	arg.", capitalizeFirstLetter(parameterName), " = float32(", capitalizeFirstLetter(parameterName), ")")
	case protoreflect.StringKind:
		g.P("	arg.", capitalizeFirstLetter(parameterName), " = ", parameterName, "Str")
	case protoreflect.BytesKind:
		g.P("	arg.", capitalizeFirstLetter(parameterName), " = []byte(", parameterName, "Str)")
	case protoreflect.BoolKind:
		g.P(" switch ", capitalizeFirstLetter(parameterName), "Str {")
		g.P("     case \"true\", \"t\", \"1\":")
		g.P("         arg.BoolValue = true")
		g.P("     case \"false\", \"f\", \"0\":")
		g.P("         arg.BoolValue = false")
		g.P("     default:")
		g.P("         return nil, ", fmtPackage.Ident("Errorf"), "(\"unknown bool string value %s\", ", capitalizeFirstLetter(parameterName), "Str)")
		g.P(" }")
	case protoreflect.EnumKind:
		g.P("	if ", parameterEnumName, "Value, ok := ", parameterEnumName, "_value[", stringsPackage.Ident("ToUpper"), "(", capitalizeFirstLetter(parameterName), "Str)]; ok {")
		g.P("		arg.", capitalizeFirstLetter(parameterName), " = ", parameterEnumName, "(", parameterEnumName, "Value)")
		g.P("	} else {")
		g.P("		if intOptionValue, err := ", strconvPackage.Ident("ParseInt"), "(", capitalizeFirstLetter(parameterName), "Str, 10, 32); err == nil {")
		g.P("			if _, ok := ", parameterEnumName, "_name[int32(intOptionValue)]; ok {")
		g.P("				arg.", capitalizeFirstLetter(parameterName), " = ", parameterEnumName, "(intOptionValue)")
		g.P("			}")
		g.P("		}")
		g.P("	}")
	default:
		return fmt.Errorf("unsupported type %s for path variable", parameterKind.String())
	}
	g.P("")
	return nil
}

// getGolangTypeName we have to substitute some of the type names for go compiler
func getGolangTypeName(parameterKind protoreflect.Kind) string {
	switch parameterKind {
	case protoreflect.Fixed64Kind:
		return protoreflect.Uint64Kind.String()
	case protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return protoreflect.Int32Kind.String()
	case protoreflect.Fixed32Kind:
		return protoreflect.Uint32Kind.String()
	}

	return parameterKind.String()
}

// genResponseHandler generates common handler for any response
func genResponseHandler(g *protogen.GeneratedFile) {
	g.P("func responseHandler(ctx *", fasthttpPackage.Ident("RequestCtx"), ", resp interface{}, respErr error) {")
	g.P("ctx.SetContentType(\"application/json\")")
	g.P("")
	g.P("if respErr == nil {")
	g.P("    ctx.SetStatusCode(", fasthttpPackage.Ident("StatusOK"), ")")
	g.P("} else {")
	g.P("    ", logPackage.Ident("Println"), "(respErr)")
	g.P("    ctx.SetStatusCode(", fasthttpPackage.Ident("StatusInternalServerError"), ")")
	g.P("}")
	g.P("")
	g.P("var data, _ = ", jsonPackage.Ident("Marshal"), "(resp)")
	g.P("_, _ = ctx.Write(data)")
	g.P("}")
}
